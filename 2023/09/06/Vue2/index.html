<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Vue2</title><meta name="author" content="Mr.张"><meta name="copyright" content="Mr.张"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么是 Vue？Vue (发音为 &#x2F;vjuː&#x2F;，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任 Vue2.x 特点 遵循 MVVM 模式，借鉴 angular 的模板和数据绑定技术，">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue2">
<meta property="og:url" content="http://zylove.com/2023/09/06/Vue2/index.html">
<meta property="og:site_name" content="老张的研究室">
<meta property="og:description" content="什么是 Vue？Vue (发音为 &#x2F;vjuː&#x2F;，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任 Vue2.x 特点 遵循 MVVM 模式，借鉴 angular 的模板和数据绑定技术，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ts1.cn.mm.bing.net/th/id/R-C.2eb9919b0ef20e2f671870ee9cb1889c?rik=oRJmtjJly1kcHg&riu=http%3a%2f%2fi0.hdslb.com%2fbfs%2farchive%2faa512eb0807633fce6d34810e7ef343fb416f707.jpg&ehk=94crFqBa0S8vifTPvminExzxIZWDbTJ7zsm8IyJDyrY%3d&risl=&pid=ImgRaw&r=0">
<meta property="article:published_time" content="2023-09-06T02:30:16.911Z">
<meta property="article:modified_time" content="2023-09-08T00:53:13.462Z">
<meta property="article:author" content="Mr.张">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ts1.cn.mm.bing.net/th/id/R-C.2eb9919b0ef20e2f671870ee9cb1889c?rik=oRJmtjJly1kcHg&riu=http%3a%2f%2fi0.hdslb.com%2fbfs%2farchive%2faa512eb0807633fce6d34810e7ef343fb416f707.jpg&ehk=94crFqBa0S8vifTPvminExzxIZWDbTJ7zsm8IyJDyrY%3d&risl=&pid=ImgRaw&r=0"><link rel="shortcut icon" href="/img/logoko.png"><link rel="canonical" href="http://zylove.com/2023/09/06/Vue2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: Mr.张","link":"Link: ","source":"Source: 老张的研究室","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Vue2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-08 09:53:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mr.张</div><div class="author-info__description"></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chenxz21/bcxm" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/resouces/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">老张的研究室</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/resouces/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Vue2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2023-09-06T02:30:16.911Z" title="Created 2023-09-06 11:30:16">2023-09-06</time></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="什么是-Vue？"><a href="#什么是-Vue？" class="headerlink" title="什么是 Vue？"></a>什么是 Vue？</h1><p>Vue (发音为 &#x2F;vjuː&#x2F;，类似 <strong>view</strong>) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任</p>
<h1 id="Vue2-x-特点"><a href="#Vue2-x-特点" class="headerlink" title="Vue2.x 特点"></a>Vue2.x 特点</h1><ol>
<li>遵循 MVVM 模式，借鉴 angular 的模板和数据绑定技术，借鉴 react 的组件化和虚拟 DOM 技术。</li>
<li>适合 移动&#x2F;PC 开发，代码简洁，体积小，运行效率高。</li>
<li>它本身只关注 UI，可以轻松引入 vue 插件或其它第三库开发项目。</li>
</ol>
<h1 id="Vue2-x-入门"><a href="#Vue2-x-入门" class="headerlink" title="Vue2.x 入门"></a><strong>Vue2.x 入门</strong></h1><p>尝试 Vue.js 最简单的方法是使用 <strong>Hello World</strong> 例子，你可以在浏览器新标签页中打开它，跟着例子学习一些基础用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &quot;Hello World&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Vue2-x-实例"><a href="#Vue2-x-实例" class="headerlink" title="Vue2.x 实例"></a>Vue2.x 实例</h2><p>每个 Vue 应用都是通过用 <code>Vue</code> 函数创建一个新的 <strong>Vue 实例</strong>开始的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  // 选项</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。</p>
<p>因此，在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示 Vue 实例。</p>
<p>当创建一个 Vue 实例时，你可以传入一个选项对象。</p>
<p>选项对象由数据、DOM、生命周期钩子、资源、组合、以及其它对象组成。</p>
<p>由于选项对象各部分并不连贯，所以会在以后的章节慢慢介绍，本章节只是介绍常用的一些对象选项。</p>
<h2 id="el"><a href="#el" class="headerlink" title="el"></a>el</h2><p><strong>类型：</strong> <code>string | Element</code></p>
<p><strong>限制：</strong> 只在用 <code>new</code> 创建实例时生效。</p>
<p><strong>介绍：</strong> 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。在实例挂载之后，元素可以用 <code>vm.$el</code> 访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">let vm = new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(vm.$el)// ==&gt; div#app对象</span><br></pre></td></tr></table></figure>

<h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>类型： Object | Function</p>
<p>限制： 组件的定义只接受 function。</p>
<p>介绍： Vue 实例的数据对象。Vue 将会递归将 data 的 property 转换为 getter&#x2F;setter，从而让 data 的 property 能够响应数据变化。浏览器 API 创建的原生对象，原型上的 property 会被忽略。实例创建之后，可以通过 vm.$data 访问原始数据对象。Vue 实例也代理了 data 对象上所有的 property，因此访问 vm.a 等价于访问 vm.$data.a。以 _ 或 $ 开头的 property 不会被 Vue 实例代理，因为它们可能和 Vue 内置的 property、API 方法冲突。你可以使用例如 vm.$data._property 的方式访问这些 property。当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。如果需要，可以通过将 vm.$data 传入 JSON.parse(JSON.stringify(…)) 得到深拷贝的原始数据对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let data = &#123;a: 1&#125;</span><br><span class="line"></span><br><span class="line">let vm = new Vue(&#123;</span><br><span class="line">    data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(vm.a)// ==&gt; 1</span><br><span class="line">console.log(vm.$data == data)// ==&gt; true</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Vue.extend() 中 data 必须是函数</span><br><span class="line">let Component = Vue.extend(&#123;</span><br><span class="line">    data: function () &#123;</span><br><span class="line">        return &#123;a: 1&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ES6提供了另外一种简写的方式</span><br><span class="line">let Component = Vue.extend(&#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;a: 1&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h2><p>类型： { [key: string]: Function }</p>
<p>介绍： methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。注意，不应该使用箭头函数来定义 method 函数 (例如 plus: () &#x3D;&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let vm = new Vue(&#123;</span><br><span class="line">    data: &#123;a: 1&#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        plus: function () &#123;</span><br><span class="line">            this.a++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.plus()</span><br><span class="line">console.log(vm.a)// 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// ES6提供了另外一种简写的方式</span><br><span class="line">let vm = new Vue(&#123;</span><br><span class="line">    data: &#123;a: 1&#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        plus() &#123;</span><br><span class="line">            this.a++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.plus()</span><br><span class="line">console.log(vm.a)// 2</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「轻松的小希」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/qq_38490457/article/details/110940631</span><br></pre></td></tr></table></figure>

<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>类型： { [key: string]: string | Function | Object | Array }</p>
<p>介绍： 一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个 property。注意，不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue &#x3D;&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">let vm = new Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        a: 1,</span><br><span class="line">        b: 2,</span><br><span class="line">        c: 3,</span><br><span class="line">        d: 4,</span><br><span class="line">        e: 5,</span><br><span class="line">        f: &#123;</span><br><span class="line">            g: 6</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        someMethod: function (newVal, oldVal) &#123;</span><br><span class="line">            console.log(&quot;new: %s, old: %s someMethod...&quot;, newVal, oldVal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        // 值可以是方法</span><br><span class="line">        a: function (newVal, oldVal) &#123;</span><br><span class="line">            console.log(&quot;new: %s, old: %s method...&quot;, newVal, oldVal)</span><br><span class="line">        &#125;,</span><br><span class="line">        // 值可以是方法名</span><br><span class="line">        b: &quot;someMethod&quot;,</span><br><span class="line">        // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深</span><br><span class="line">        c: &#123;</span><br><span class="line">            deep: true,</span><br><span class="line">            handler: function (newVal, oldVal) &#123;</span><br><span class="line">                console.log(&quot;new: %s, old: %s deep...&quot;, newVal, oldVal)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 该回调将会在侦听开始之后被立即调用</span><br><span class="line">        d: &#123;</span><br><span class="line">            immediate: true,</span><br><span class="line">            handler: function (newVal, oldVal) &#123;</span><br><span class="line">                console.log(&quot;new: %s, old: %s immediate...&quot;, newVal, oldVal)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 你可以传入回调数组，它们会被逐一调用</span><br><span class="line">        e: [</span><br><span class="line">            function handle1(newVal, oldVal) &#123;</span><br><span class="line">                console.log(&quot;new: %s, old: %s handle1...&quot;, newVal, oldVal)</span><br><span class="line">            &#125;,</span><br><span class="line">            function handle2(newVal, oldVal) &#123;</span><br><span class="line">                console.log(&quot;new: %s, old: %s handle2...&quot;, newVal, oldVal)</span><br><span class="line">            &#125;,</span><br><span class="line">            function handle3(newVal, oldVal) &#123;</span><br><span class="line">                console.log(&quot;new: %s, old: %s handle3...&quot;, newVal, oldVal)</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        // 你可以观察一个对象的某一个属性值</span><br><span class="line">        &#x27;f.g&#x27;: function (newVal, oldVal) &#123;</span><br><span class="line">            console.log(&quot;new: %s, old: %s f.g...&quot;, newVal, oldVal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.a = 11</span><br><span class="line">vm.b = 22</span><br><span class="line">vm.c = 33</span><br><span class="line">vm.d = 44</span><br><span class="line">vm.e = 55</span><br><span class="line">vm.f.g = 66</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/06/Vue2/7df79de6281ba6355b438b5c96a27791.png" alt="这是图片" title="Magic Gardens"></p>
<h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p><strong>类型：</strong> { [key: string]: Function | { get: Function, set: Function } }&#96;</p>
<p><strong>介绍：</strong> 计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。注意如果你为一个计算属性使用了箭头函数，则 <code>this</code> 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  aDouble: vm =&gt; vm.a * 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算属性的结果会被缓存，除非依赖的响应式 property 变化才会重新计算。注意，如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是<strong>不会</strong>被更新的。计算属性默认只有 getter，不过在需要时你也可以提供一个 setter。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let vm = new Vue(&#123;</span><br><span class="line">    data: &#123;a: 1&#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        // 仅读取</span><br><span class="line">        aDouble: function () &#123;</span><br><span class="line">            return this.a * 2</span><br><span class="line">        &#125;,</span><br><span class="line">        // 读取和设置</span><br><span class="line">        aPlus: &#123;</span><br><span class="line">            get: function () &#123;</span><br><span class="line">                return this.a + 1</span><br><span class="line">            &#125;,</span><br><span class="line">            set: function (v) &#123;</span><br><span class="line">                this.a = v - 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(vm.aPlus)       // =&gt; 2</span><br><span class="line">vm.aPlus = 3</span><br><span class="line">console.log(vm.a)           // =&gt; 2</span><br><span class="line">console.log(vm.aDouble)     // =&gt; 4</span><br></pre></td></tr></table></figure>

<p><img src="/2023/09/06/Vue2/b96f3b58a4f3bb13e1c3f8abd5c305f7.png" alt="img"></p>
<h1 id="Vue2-x-指令指南"><a href="#Vue2-x-指令指南" class="headerlink" title="Vue2.x 指令指南"></a>Vue2.x 指令指南</h1><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a><p style="font-size:23px">插值</p></h3><h4 id="text"><a href="#text" class="headerlink" title="text"></a><p style="font-size:20px">text</p></h4><p>数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>Mustache 标签将会被替代为对应数据对象上 <code>msg</code> property 的值。</p>
<p>无论何时，绑定的数据对象上 <code>msg</code> property 发生了改变，插值处的内容都会更新。</p>
<p>通过使用 <strong>v-text 指令</strong>，你也能执行文本插值，当数据改变时，插值处的内容也会更新。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;!-- 和下面的一样 --&gt;</span><br><span class="line">&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>通过使用 <strong>v-once 指令</strong>，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。</p>
<p>但请留心这会影响到该节点上的其它数据绑定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<h4 id="html"><a href="#html" class="headerlink" title="html"></a><p style="font-size:20px">html</p></h4><p>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 <strong>v-html 指令</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h4 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a><p style="font-size:20px">attribute</p></h4><p style="font-size:20px"></p>
 Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 **v-bind 指令** ：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>对于布尔 attribute (它们只要存在就意味着值为 <code>true</code>)，<code>v-bind</code> 工作起来略有不同，在这个例子中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>如果 <code>isButtonDisabled</code> 的值是 <code>null</code>、<code>undefined</code> 或 <code>false</code>，则 <code>disabled</code> 属性甚至不会被包含在渲染出来的 <code>&lt;button&gt;</code> 元素中。</p>
<h4 id="expression"><a href="#expression" class="headerlink" title="expression"></a><p style="font-size:20px">expression</p></h4><p>迄今为止，在我们的模板中，我们一直都只绑定简单的 property 键值。</p>
<p>但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;div v-bind:id=&quot;&#x27;list-&#x27; + id&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。</p>
<p>有个限制就是，每个绑定都只能包含<strong>单个表达式</strong>，所以下面的例子都<strong>不会</strong>生效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这是语句，不是表达式 --&gt;</span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>模板表达式都被放在沙盒中，只能访问<strong>全局变量的一个白名单</strong>，如 <code>Math</code> 和 <code>Date</code> 。</p>
<p>你不应该在模板表达式中试图访问用户定义的全局变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 全局变量的一个白名单</span><br><span class="line">const allowedGlobals = makeMap(</span><br><span class="line">    &#x27;Infinity,undefined,NaN,isFinite,isNaN,&#x27; +</span><br><span class="line">    &#x27;parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,&#x27; +</span><br><span class="line">    &#x27;Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,&#x27; +</span><br><span class="line">    &#x27;require&#x27; // for Webpack/Browserify</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a><p style="font-size:23px">指令</p></h3><pre><code>指令 (Directives) 是带有 v- 前缀的特殊 attribute。
</code></pre>
<p>指令 attribute 的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)。</p>
<p>指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。回顾我们在介绍中看到的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>这里，<code>v-if</code> 指令将根据表达式 <code>seen</code> 的值的真假来插入&#x2F;移除 <code>&lt;p&gt;</code> 元素。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a><p style="font-size:20px">参数</p></h4><p>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。</p>
<p>例如，<code>v-bind</code> 指令可以用于响应式地更新 HTML attribute：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>在这里 <code>href</code> 是参数，告知 <code>v-bind</code> 指令将该元素的 <code>href</code> attribute 与表达式 <code>url</code> 的值绑定。</p>
<p>另一个例子是 <code>v-on</code> 指令，它用于监听 DOM 事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>在这里参数是监听的事件名。我们也会更详细地讨论事件处理。</p>
<h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a><p style="font-size:20px">动态参数</p></h4><p>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*&lt;!-- 注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述 --&gt;*</span><br><span class="line">&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。</p>
<p>例如，如果你的 Vue 实例有一个 data property attributeName，其值为 “href”，那么这个绑定将等价于 v-bind:href。</p>
<p>同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，当 <code>eventName</code> 的值为 <code>&quot;focus&quot;</code> 时，<code>v-on:[eventName]</code> 将等价于 <code>v-on:focus</code>。</p>
<p><strong>对动态参数的值的约束</strong></p>
<p>动态参数预期会求出一个字符串，异常情况下值为 <code>null</code>。这个特殊的 <code>null</code> 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。</p>
<p><strong>对动态参数表达式的约束</strong></p>
<p>动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这会触发一个编译警告 --&gt;</span><br><span class="line">&lt;a v-bind:[&#x27;foo&#x27; + bar]=&quot;value&quot;&gt; ... &lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。</p>
<p>在 DOM 中使用模板时，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。</span><br><span class="line">除非在实例中有一个名为“someattr”的 property，否则代码不会工作。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;a v-bind:[someAttr]=&quot;value&quot;&gt; ... &lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a><p style="font-size:20px">修饰符</p></h4><p>修饰符 (modifier) 是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。</p>
<p>例如，<code>.prevent</code> 修饰符告诉 <code>v-on</code> 指令对于触发的事件调用 <code>event.preventDefault()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>在接下来对 <strong>v-on</strong> 和 <strong>v-for</strong> 等功能的探索中，你会看到修饰符的其它例子。</p>
<h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a><p style="font-size:23px">缩写</p></h3><p>v- 前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，v- 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。同时，在构建由 Vue 管理所有模板的单页面应用程序 (SPA) 时，v- 前缀也变得没那么重要了。因此，Vue 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写，它们看起来可能与普通的 HTML 略有不同，但 : 与 @ 对于 attribute 名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。</p>
<h4 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a><p style="font-size:20px">v-bind 缩写</p></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="line">&lt;a :[key]=&quot;url&quot;&gt; ... &lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h4 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a><p style="font-size:20px">v-on 缩写</p></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="line">&lt;a @[event]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="深入"><a href="#深入" class="headerlink" title="深入"></a><p style="font-size:23px">深入</p></h3><p>到这里你已经掌握了 <code>v-bind</code> 、 <code>v-on</code> 的基本使用，接下来将会介绍高级使用，但是现在我们建议你直接跳过这一小节<strong>深入</strong> ，上边所学的知识已经可以支撑你接下来的学习了，当你把<strong>教程全部学完</strong>以后，我们才建议你重新阅读本章内容，到时候你就会感觉无比轻松。</p>
<h4 id="v-bind-深入"><a href="#v-bind-深入" class="headerlink" title="v-bind 深入"></a><p style="font-size:20px">v-bind 深入</p></h4><p><strong>缩写</strong>： :</p>
<p><strong>预期</strong>： any (with argument) | Object (without argument)</p>
<p><strong>参数</strong>：attrOrProp (optional)</p>
<p><strong>修饰符</strong>：</p>
<p>.prop - 作为一个 DOM property 绑定而不是作为 attribute 绑定。</p>
<p>.camel - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持)<br>​ .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。</p>
<p><strong>用法</strong>：</p>
<pre><code>        动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。
</code></pre>
<p>在绑定 class 或 style attribute 时，支持其它类型的值，如数组或对象。</p>
<p>在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。</p>
<p>没有参数时，可以绑定到一个包含键值对的对象。注意此时 class 和 style 绑定不支持数组和对象。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 绑定一个 attribute --&gt;</span><br><span class="line">&lt;img v-bind:src=&quot;imageSrc&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态 attribute 名 (2.6.0+) --&gt;</span><br><span class="line">&lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;img :src=&quot;imageSrc&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态 attribute 名缩写 (2.6.0+) --&gt;</span><br><span class="line">&lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 内联字符串拼接 --&gt;</span><br><span class="line">&lt;img :src=&quot;&#x27;/path/to/images/&#x27; + fileName&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- class 绑定 --&gt;</span><br><span class="line">&lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div :class=&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- style 绑定 --&gt;</span><br><span class="line">&lt;div :style=&quot;&#123; fontSize: size + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 绑定一个全是 attribute 的对象 --&gt;</span><br><span class="line">&lt;div v-bind=&quot;&#123; id: someProp, &#x27;other-attr&#x27;: otherProp &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 通过 prop 修饰符绑定 DOM attribute --&gt;</span><br><span class="line">&lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;</span><br><span class="line">&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;</span><br><span class="line">&lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- XLink --&gt;</span><br><span class="line">&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure>

<p><code>.camel</code> 修饰符允许在使用 DOM 模板时将 <code>v-bind</code> property 名称驼峰化，例如 SVG 的 <code>viewBox</code> property：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg :view-box.camel=&quot;viewBox&quot;&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure>

<p>在使用字符串模板或通过 <code>vue-loader</code>&#x2F;<code>vueify</code> 编译时，无需使用 <code>.camel</code>。</p>
<h4 id="v-on-深入"><a href="#v-on-深入" class="headerlink" title="v-on 深入"></a><p style="font-size:20px">v-on 深入</p></h4><p><strong>缩写</strong>：@</p>
<p><strong>预期</strong>：Function | Inline Statement | Object</p>
<p><strong>参数</strong>：event</p>
<p><strong>修饰</strong>符：</p>
<p>.stop - 调用 event.stopPropagation()。<br>.prevent - 调用 event.preventDefault()。<br>.capture - 添加事件侦听器时使用 capture 模式。<br>.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。<br>.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。<br>.native - 监听组件根元素的原生事件。<br>.once - 只触发一次回调。<br>.left - (2.2.0) 只当点击鼠标左键时触发。<br>.right - (2.2.0) 只当点击鼠标右键时触发。<br>.middle - (2.2.0) 只当点击鼠标中键时触发。<br>.passive - (2.3.0) 以 { passive: true } 模式添加侦听器</p>
<p><strong>用法</strong>：</p>
<pre><code>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。
</code></pre>
<p>用在普通元素上时，只能监听原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。</p>
<p>在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 $event property：v-on:click&#x3D;”handle(‘ok’, $event)”。</p>
<p>从 2.4.0 开始，v-on 同样支持不带参数绑定一个事件&#x2F;监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。</p>
<p><strong>示例</strong>：</p>
<pre><code>&lt;!-- 方法处理器 --&gt;
&lt;button v-on:click=&quot;doThis&quot;&gt;&lt;/button&gt;

&lt;!-- 动态事件 (2.6.0+) --&gt;
&lt;button v-on:[event]=&quot;doThis&quot;&gt;&lt;/button&gt;

&lt;!-- 内联语句 --&gt;
&lt;button v-on:click=&quot;doThat(&#39;hello&#39;, $event)&quot;&gt;&lt;/button&gt;

&lt;!-- 缩写 --&gt;
&lt;button @click=&quot;doThis&quot;&gt;&lt;/button&gt;

&lt;!-- 动态事件缩写 (2.6.0+) --&gt;
&lt;button @[event]=&quot;doThis&quot;&gt;&lt;/button&gt;

&lt;!-- 停止冒泡 --&gt;
&lt;button @click.stop=&quot;doThis&quot;&gt;&lt;/button&gt;

&lt;!-- 阻止默认行为 --&gt;
&lt;button @click.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;

&lt;!-- 阻止默认行为，没有表达式 --&gt;

&lt;form @submit.prevent&gt;&lt;/form&gt;

&lt;!--  串联修饰符 --&gt;
&lt;button @click.stop.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;

&lt;!-- 键修饰符，键别名 --&gt;
&lt;input @keyup.enter=&quot;onEnter&quot;&gt;

&lt;!-- 键修饰符，键代码 --&gt;
&lt;input @keyup.13=&quot;onEnter&quot;&gt;

&lt;!-- 点击回调只会触发一次 --&gt;
&lt;button v-on:click.once=&quot;doThis&quot;&gt;&lt;/button&gt;

&lt;!-- 对象语法 (2.4.0+) --&gt;
&lt;button v-on=&quot;&#123; mousedown: doThis, mouseup: doThat &#125;&quot;&gt;&lt;/button&gt;
</code></pre>
<p>在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component @my-event=&quot;handleThis&quot;&gt;&lt;/my-component&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 内联语句 --&gt;</span><br><span class="line">&lt;my-component @my-event=&quot;handleThis(123, $event)&quot;&gt;&lt;/my-component&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 组件中的原生事件 --&gt;</span><br><span class="line">&lt;my-component @click.native=&quot;onClick&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>

<h2 id="样式绑定"><a href="#样式绑定" class="headerlink" title="样式绑定"></a>样式绑定</h2><p>操作元素的 class 列表和内联 style 样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 v-bind 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</p>
<h3 id="绑定-class"><a href="#绑定-class" class="headerlink" title="绑定 class"></a><p style="font-size:23px">绑定 class</p></h3><h4 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a><p style="font-size:20px">对象语法</p></h4><p>我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>上面的语法表示 <code>active</code> 这个 class 存在与否将取决于数据 property <code>isActive</code> 的真值。</p>
<p>你可以在对象中传入更多字段来动态切换多个 class。</p>
<p>此外，<code>v-bind:class</code> 指令也可以与普通的 class attribute 共存。当有如下模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>和如下 data：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果渲染为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>当 <code>isActive</code> 或者 <code>hasError</code> 变化时，class 列表将相应地更新。</p>
<p>例如，如果 <code>hasError</code> 的值为 <code>true</code>，class 列表将变为 <code>&quot;static active text-danger&quot;</code>。</p>
<p>绑定的数据对象不必内联定义在模板里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: true,</span><br><span class="line">    &#x27;text-danger&#x27;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染的结果和上面一样。我们也可以在这里绑定一个返回对象的<strong>计算属性</strong>。这是一个常用且强大的模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  error: null</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      active: this.isActive &amp;&amp; !this.error,</span><br><span class="line">      &#x27;text-danger&#x27;: this.error &amp;&amp; this.error.type === &#x27;fatal&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a><p style="font-size:20px">数组语法</p></h4><p>我们可以把一个数组传给 <code>v-bind:class</code>，以应用一个 class 列表：</p>
<pre><code>&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这样写将始终添加 <code>errorClass</code>，但是只有在 <code>isActive</code> 是真值时才添加 <code>activeClass</code>。</p>
<p>不过，当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上"></a><p style="font-size:20px">用在组件上</p></h4><p>注意：这个章节假设你已经对 <strong>Vue 组件</strong> 有一定的了解。当然你也可以先跳过这里，稍后再回过头来看。</p>
<p>当在一个自定义组件上使用 <code>class</code> property 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。例如，如果你声明了这个组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;my-component&#x27;, &#123;</span><br><span class="line">  template: &#x27;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后在使用它的时候添加一些 class：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>

<p>HTML 将被渲染为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>对于带数据绑定 class 也同样适用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>

<p>当 <code>isActive</code> 为真值时，HTML 将被渲染成为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;foo bar active&quot;&gt;Hi&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a><p style="font-size:23px">条件渲染</p></h2><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a><p style="font-size:20px">v-if</p></h3><p><code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回真值的时候被渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>也可以用 <code>v-else</code> 添加一个“else 块”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;Oh no&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>从 2.1.0 开始，新增了<code>v-else-if</code>，顾名思义，充当 <code>v-if</code> 的“else-if 块”，可以连续使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt;</span><br><span class="line">  A</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;</span><br><span class="line">  B</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;</span><br><span class="line">  C</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Not A/B/C</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。</p>
<p>因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？</p>
<p>此时可以把一个 <template> 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 <template> 元素。</template></template></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;ok&quot;&gt;</span><br><span class="line">  &lt;h1&gt;Title&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 1&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Paragraph 2&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。</p>
<p>这么做除了使 Vue 变得非常快之外，还有其它一些好处。</p>
<p>例如，如果你允许用户在不同的登录方式之间切换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &#x27;username&#x27;&quot;&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your username&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。</p>
<p>因为两个模板使用了相同的元素，<input> 不会被替换掉，仅仅是替换了它的 placeholder。</p>
<p>这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。</p>
<p>只需添加一个具有唯一值的 key attribute 即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &#x27;username&#x27;&quot;&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>现在，每次切换时，输入框都将被重新渲染。</p>
<p>注意，<code>&lt;label&gt;</code> 元素仍然会被高效地复用，因为它们没有添加 <code>key</code> attribute。</p>
<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><p style="font-size:20px">v-show</p></h3><p>另一个用于根据条件展示元素的选项是 <code>v-show</code> 指令。用法大致一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display。</p>
<p>注意，v-show 不支持 <template> 元素，也不支持 v-else。</template></p>
<h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a><p style="font-size:23px">列表渲染</p></h2><h3 id="v-for-遍历数组"><a href="#v-for-遍历数组" class="headerlink" title="v-for 遍历数组"></a><p style="font-size:20px">v-for 遍历数组</p></h3><p>我们可以用 <code>v-for</code> 指令基于一个数组来渲染一个列表。</p>
<p><code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据数组，而 <code>item</code> 则是被迭代的数组元素的<strong>别名</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;example-1&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in items&quot; :key=&quot;item.message&quot;&gt;</span><br><span class="line">    &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let example1 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#example-1&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">      &#123; message: &#x27;Foo&#x27; &#125;,</span><br><span class="line">      &#123; message: &#x27;Bar&#x27; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在 <code>v-for</code> 块中，我们可以访问所有父作用域的 property。<code>v-for</code> 还支持一个可选的第二个参数，即当前项的索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;example-2&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;(item, index) in items&quot;&gt;</span><br><span class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let example2 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#example-2&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    parentMessage: &#x27;Parent&#x27;,</span><br><span class="line">    items: [</span><br><span class="line">      &#123; message: &#x27;Foo&#x27; &#125;,</span><br><span class="line">      &#123; message: &#x27;Bar&#x27; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你也可以用 <code>of</code> 替代 <code>in</code> 作为分隔符，因为它更接近 JavaScript 迭代器的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="v-for-遍历对象"><a href="#v-for-遍历对象" class="headerlink" title="v-for 遍历对象"></a><p style="font-size:20px">v-for 遍历对象</p></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;example-3&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;value in object&quot;&gt;</span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let example3 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#example-3&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    object: &#123;</span><br><span class="line">      title: &#x27;How to do lists in Vue&#x27;,</span><br><span class="line">      author: &#x27;Jane Doe&#x27;,</span><br><span class="line">      publishedAt: &#x27;2016-04-10&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你也可以提供第二个的参数为 property 名称 (也就是键名)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;(value, name) in object&quot;&gt;</span><br><span class="line">  &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>还可以用第三个参数作为索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;(value, name, index) in object&quot;&gt;</span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>注意：在遍历对象时，会按 <code>Object.keys()</code> 的结果遍历，但是<strong>不能</strong>保证它的结果在不同的 JavaScript 引擎下都一致。</p>
<h3 id="v-for-维护状态"><a href="#v-for-维护状态" class="headerlink" title="v-for 维护状态"></a><p style="font-size:20px">v-for 维护状态</p></h3><p>当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 track-by&#x3D;”$index”。</p>
<p>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。</p>
<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=&quot;item in items&quot; v-bind:key=&quot;item.id&quot;&gt;</span><br><span class="line">  &lt;!-- 内容 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code> attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p>
<p>因为它是 Vue 识别节点的一个通用机制，<code>key</code> 并不仅与 <code>v-for</code> 特别关联。后面我们将在指南中看到，它还具有其它用途。</p>
<p>注意：不要使用对象或数组之类的非基本类型值作为 <code>v-for</code> 的 <code>key</code>。请用字符串或数值类型的值。</p>
<h3 id="v-for-更新检测"><a href="#v-for-更新检测" class="headerlink" title="v-for 更新检测"></a><p>v-for 更新检测</p></h3><p>由于 JavaScript 的限制，Vue <strong>不能检测</strong>数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。</p>
<p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
<p>你可以打开控制台，然后对前面例子的 items 数组尝试调用变更方法。比如 example1.items.push({ message: ‘Baz’ })。</p>
<p>变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example1.items = example1.items.filter(function (item) &#123;</span><br><span class="line">  return item.message.match(/Foo/)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。</p>
<h3 id="v-for-过滤排序"><a href="#v-for-过滤排序" class="headerlink" title="v-for 过滤排序"></a><p>v-for 过滤排序</p></h3><p>有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。</p>
<p>在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  numbers: [ 1, 2, 3, 4, 5 ]</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  evenNumbers: function () &#123;</span><br><span class="line">    return this.numbers.filter(function (number) &#123;</span><br><span class="line">      return number % 2 === 0</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在计算属性不适用的情况下 (例如，在嵌套 <code>v-for</code> 循环中) 你可以使用一个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul v-for=&quot;set in sets&quot;&gt;</span><br><span class="line">&lt;li v-for=&quot;n in even(set)&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  even: function (numbers) &#123;</span><br><span class="line">    return numbers.filter(function (number) &#123;</span><br><span class="line">      return number % 2 === 0</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="v-for-限制范围"><a href="#v-for-限制范围" class="headerlink" title="v-for 限制范围"></a><p>v-for 限制范围</p></h3><p><code>v-for</code> 也可以接受整数，在这种情况下，它会把模板重复对应次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="v-for-在模板上使用"><a href="#v-for-在模板上使用" class="headerlink" title="v-for 在模板上使用"></a><p>v-for 在模板上使用</p></h3><p>类似于 <code>v-if</code>，你也可以利用带有 <code>v-for</code> 的 <code>&lt;template&gt;</code> 来循环渲染一段包含多个元素的内容。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;template v-for=&quot;item in items&quot;&gt;</span><br><span class="line">    &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;li class=&quot;divider&quot; role=&quot;presentation&quot;&gt;&lt;/li&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h3 id="v-for-在组件上使用"><a href="#v-for-在组件上使用" class="headerlink" title="v-for 在组件上使用"></a><p>v-for 在组件上使用</p></h3><p>注意：这个章节假设你已经对 <strong>Vue 组件</strong> 有一定的了解。当然你也可以先跳过这里，稍后再回过头来看。</p>
<p>在自定义组件上，你可以像在任何普通元素上一样使用 <code>v-for</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>

<p>注意：2.2.0+ 的版本里，当在组件上使用 <code>v-for</code> 时，<code>key</code> 现在是必须的。</p>
<p>然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。</p>
<p>为了把迭代数据传递到组件里，我们要使用 prop：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-for=&quot;(item, index) in items&quot;</span><br><span class="line">  v-bind:item=&quot;item&quot;</span><br><span class="line">  v-bind:index=&quot;index&quot;</span><br><span class="line">  v-bind:key=&quot;item.id&quot;</span><br><span class="line">&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>

<p>不自动将 <code>item</code> 注入到组件里的原因是，这会使得组件与 <code>v-for</code> 的运作紧密耦合。</p>
<p>明确组件数据的来源能够使组件在其他场合重复使用。</p>
<p>下面是一个简单的 todo 列表的完整例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;todo-list-example&quot;&gt;</span><br><span class="line">    &lt;form v-on:submit.prevent=&quot;addNewTodo&quot;&gt;</span><br><span class="line">        &lt;label for=&quot;new-todo&quot;&gt;Add a todo&lt;/label&gt;</span><br><span class="line">        &lt;input v-model=&quot;newTodoText&quot; id=&quot;new-todo&quot;&gt;</span><br><span class="line">        &lt;button&gt;Add&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li</span><br><span class="line">            is=&quot;todo-item&quot;</span><br><span class="line">            v-for=&quot;(todo, index) in todos&quot;</span><br><span class="line">            v-bind:key=&quot;todo.id&quot;</span><br><span class="line">            v-bind:title=&quot;todo.title&quot;</span><br><span class="line">            v-on:remove=&quot;todos.splice(index, 1)&quot;</span><br><span class="line">        &gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>注意这里的 <code>is=&quot;todo-item&quot;</code> attribute。这种做法在使用 DOM 模板时是十分必要的，因为在 <code>&lt;ul&gt;</code> 元素内只有 <code>&lt;li&gt;</code> 元素会被看作有效内容。这样做实现的效果与 <code>&lt;todo-item&gt;</code> 相同，但是可以避开一些潜在的浏览器解析错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;todo-item&#x27;, &#123;</span><br><span class="line">    template: &#x27;&lt;li&gt;&#123;&#123; title &#125;&#125; &lt;button v-on:click=&quot;$emit(\&#x27;remove\&#x27;)&quot;&gt;Remove&lt;/button&gt;&lt;/li&gt;&#x27;,</span><br><span class="line">    props: [&#x27;title&#x27;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#todo-list-example&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        newTodoText: &#x27;&#x27;,</span><br><span class="line">        todos: [</span><br><span class="line">            &#123;id: 1, title: &#x27;This is title 1&#x27;,&#125;,</span><br><span class="line">            &#123;id: 2, title: &#x27;This is title 2&#x27;,&#125;,</span><br><span class="line">            &#123;id: 3, title: &#x27;This is title 3&#x27;,&#125;</span><br><span class="line">        ],</span><br><span class="line">        nextTodoId: 4</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        addNewTodo: function () &#123;</span><br><span class="line">            this.todos.push(&#123;</span><br><span class="line">                id: this.nextTodoId++,</span><br><span class="line">                title: this.newTodoText</span><br><span class="line">            &#125;)</span><br><span class="line">            this.newTodoText = &#x27;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<img src="/2023/09/06/Vue2/ab02ffa186a00f71bba3a2aeef1506ce.gif">

<h3 id="v-for-注意事项"><a href="#v-for-注意事项" class="headerlink" title="v-for 注意事项"></a><p>v-for 注意事项</p></h3><p>注意我们<strong>不</strong>推荐在同一元素上使用 <code>v-if</code> 和 <code>v-for</code>。</p>
<p>当它们处于同一节点，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环中。</p>
<p>当你只想为部分项渲染节点时，这种优先级的机制会十分有用，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;</span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>

<p>上面的代码将只渲染未完成的 todo。</p>
<p>而如果你的目的是有条件地跳过循环的执行，那么可以将 <code>v-if</code> 置于外层元素 (或 <code>&lt;template&gt;</code>) 上。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul v-if=&quot;todos.length&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;todo in todos&quot;&gt;</span><br><span class="line">    &#123;&#123; todo &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;p v-else&gt;No todos left!&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a><p style="font-size:23px">事件处理</p></h2><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a><p style="font-size:20px">事件监听</p></h3><p>可以用 <code>v-on</code> 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example-1&quot;&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt;</span><br><span class="line">  &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example-1&quot;&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt;</span><br><span class="line">  &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="事件处理-1"><a href="#事件处理-1" class="headerlink" title="事件处理"></a><p style="font-size:20px">事件处理</p></h3><p>然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 <code>v-on</code> 指令中是不可行的。</p>
<p>因此 <code>v-on</code> 还可以接收一个需要调用的方法名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example-2&quot;&gt;</span><br><span class="line">  &lt;!-- `greet` 是在下面定义的方法名 --&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var example2 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#example-2&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: &#x27;Vue.js&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 在 `methods` 对象中定义方法</span><br><span class="line">  methods: &#123;</span><br><span class="line">    greet: function (event) &#123;</span><br><span class="line">      // `this` 在方法里指向当前 Vue 实例</span><br><span class="line">      alert(&#x27;Hello &#x27; + this.name + &#x27;!&#x27;)</span><br><span class="line">      // `event` 是原生 DOM 事件</span><br><span class="line">      if (event) &#123;</span><br><span class="line">        alert(event.target.tagName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a><p style="font-size:20px">事件修饰符</p></h3><p>在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。</p>
<p>尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p>
<p>为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。</p>
<ul>
<li><p><code>.stop</code></p>
</li>
<li><p><code>.prevent</code></p>
</li>
<li><p><code>.capture</code></p>
</li>
<li><p><code>.self</code></p>
</li>
<li><p><code>.once</code></p>
</li>
<li><p><code>.passive</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只有修饰符 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span><br><span class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span><br><span class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 2.1.4 新增，点击事件将只会触发一次 --&gt;</span><br><span class="line">&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 2.3.0 新增，滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span><br><span class="line">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span><br><span class="line">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span><br><span class="line">&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>使用修饰符时，顺序很重要，相应的代码会以同样的顺序产生。</p>
<p>因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素<strong>自身的点击</strong>。</p>
<p>不像其它只能对原生的 DOM 事件起作用的修饰符，.once 修饰符还能被用到自定义的组件事件上。如果你还没有阅读关于组件的文档，现在大可不必担心。</p>
<p>这个 .passive 修饰符尤其能够提升移动端的性能。不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。</p>
<h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a><p style="font-size:20px">按键修饰符</p></h3><p>在监听键盘事件时，我们经常需要检查详细的按键。</p>
<p>Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span><br><span class="line">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>你可以直接将 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values"><code>KeyboardEvent.key</code></a> 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-on:keyup.page-down=&quot;onPageDown&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，处理函数只会在 $event.key 等于 PageDown 时被调用。</p>
<p>为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名：</p>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (捕获“删除”和“退格”键)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<p>有一些按键 (.esc 以及所有的方向键) 在 IE9 中有不同的 key 值，如果你想支持 IE9，这些内置的别名应该是首选。</p>
<p>你还可以通过全局 config.keyCodes 对象自定义按键修饰符别名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 可以使用 `v-on:keyup.f1`</span><br><span class="line">Vue.config.keyCodes.f1 = 112</span><br></pre></td></tr></table></figure>

<h3 id="系统修饰符"><a href="#系统修饰符" class="headerlink" title="系统修饰符"></a><p style="font-size:20px">系统修饰符</p></h3><p>在 2.1.0 新增系统修饰符中，可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<p>注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Alt + C --&gt;</span><br><span class="line">&lt;input v-on:keyup.alt.67=&quot;clear&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Ctrl + Click --&gt;</span><br><span class="line">&lt;div v-on:click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>请注意修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态。</p>
<p>换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。而单单释放 ctrl 也不会触发事件。</p>
<p>如果你想要这样的行为，请为 ctrl 换用 keyCode：keyup.17。</p>
<p>在 2.5.0 新增系统修饰符中，.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="line">&lt;button v-on:click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button v-on:click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button v-on:click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>在 2.2.0 新增鼠标按钮修饰符中，这些修饰符会限制处理函数仅响应特定的鼠标按钮。</p>
<ul>
<li><code>.left</code></li>
<li><code>.right</code></li>
<li><code>.middle</code></li>
</ul>
<h2 id="表单绑定"><a href="#表单绑定" class="headerlink" title="表单绑定"></a><p style="font-size:23px">表单绑定</p></h2><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a><p style="font-size:20px">基础用法</p></h3><p>你可以用 v-model 指令在表单 <input>、<textarea> 及 </textarea><select> 元素上创建双向数据绑定。</select></p>
<p>它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。</p>
<p>它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</p>
<p>v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。</p>
<p>你应该通过 JavaScript 在组件的 data 选项中声明初始值。</p>
<p>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li>
<li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</li>
<li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li>
</ul>
<h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a><p style="font-size:20px">文本</p></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;</span><br><span class="line">&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h4 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a><p style="font-size:20px">多行文本</p></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h4 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a><p style="font-size:20px">复选框</p></h4><p>单个复选框，绑定到布尔值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; checked &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        checked: false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>多个复选框，绑定到同一个数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;</span><br><span class="line">    &lt;p&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        checkedNames: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a><p style="font-size:20px">单选按钮</p></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;</span><br><span class="line">    &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;</span><br><span class="line">    &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;</span><br><span class="line">    &lt;p&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        picked: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="选择框"><a href="#选择框" class="headerlink" title="选择框"></a><p style="font-size:20px">选择框</p></h4><p>单选时（绑定到一个变量）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;select v-model=&quot;selected&quot;&gt;</span><br><span class="line">        &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;A&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;B&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;C&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    &lt;p&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        selected: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意：如果 <code>v-model</code> 表达式的初始值未能匹配任何选项，<code>&lt;select&gt;</code> 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。</p>
<p>多选时（绑定到一个数组）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;select v-model=&quot;selected&quot; multiple style=&quot;width: 50px;&quot;&gt;</span><br><span class="line">        &lt;option&gt;A&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;B&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;C&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    &lt;p&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        selected: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>用 <code>v-for</code> 渲染的动态选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;select v-model=&quot;selected&quot;&gt;</span><br><span class="line">        &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt;</span><br><span class="line">            &#123;&#123; option.text &#125;&#125;</span><br><span class="line">        &lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    &lt;p&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        selected: &#x27;A&#x27;,</span><br><span class="line">        options: [</span><br><span class="line">            &#123;text: &#x27;One&#x27;, value: &#x27;A&#x27;&#125;,</span><br><span class="line">            &#123;text: &#x27;Two&#x27;, value: &#x27;B&#x27;&#125;,</span><br><span class="line">            &#123;text: &#x27;Three&#x27;, value: &#x27;C&#x27;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a><p style="font-size:23px">值绑定</p></h3><p>对于单选按钮，复选框及选择框的选项，<code>v-model</code> 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 当选中时，`picked` 为字符串 &quot;a&quot; --&gt;</span><br><span class="line">&lt;input type=&quot;radio&quot; v-model=&quot;picked&quot; value=&quot;a&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- `toggle` 为 true 或 false --&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 当选中第一个选项时，`selected` 为字符串 &quot;abc&quot; --&gt;</span><br><span class="line">&lt;select v-model=&quot;selected&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;abc&quot;&gt;ABC&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>但是有时我们可能想把值绑定到 Vue 实例的一个动态属性上，这时可以用 <code>v-bind</code> 实现，并且这个 property 的值可以不是字符串。</p>
<h4 id="复选框-1"><a href="#复选框-1" class="headerlink" title="复选框"></a><p style="font-size:20px">复选框</p></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  type=&quot;checkbox&quot;</span><br><span class="line">  v-model=&quot;toggle&quot;</span><br><span class="line">  true-value=&quot;yes&quot;</span><br><span class="line">  false-value=&quot;no&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 当选中时</span><br><span class="line">vm.toggle === &#x27;yes&#x27;</span><br><span class="line">// 当没有选中时</span><br><span class="line">vm.toggle === &#x27;no&#x27;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>true-value</code> 和 <code>false-value</code> attribute 并不会影响输入控件的 <code>value</code> attribute，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(即“yes”或“no”)，请换用单选按钮。</p>
<h4 id="单选按钮-1"><a href="#单选按钮-1" class="headerlink" title="单选按钮"></a><p style="font-size:20px">单选按钮</p></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; v-bind:value=&quot;a&quot;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 当选中时</span><br><span class="line">vm.pick === vm.a</span><br></pre></td></tr></table></figure>

<h4 id="选择框-1"><a href="#选择框-1" class="headerlink" title="选择框"></a><p style="font-size:20px">选择框</p></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select v-model=&quot;selected&quot;&gt;</span><br><span class="line">    &lt;!-- 内联对象字面量 --&gt;</span><br><span class="line">  &lt;option v-bind:value=&quot;&#123; number: 123 &#125;&quot;&gt;123&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 当选中时</span><br><span class="line">typeof vm.selected // =&gt; &#x27;object&#x27;</span><br><span class="line">vm.selected.number // =&gt; 123</span><br></pre></td></tr></table></figure>

<h3 id="修饰符-1"><a href="#修饰符-1" class="headerlink" title="修饰符"></a><p style="font-size:23px">修饰符</p><p></p></h3><h4 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a><p style="font-size:20px"><code>.lazy</code></p></h4><p>在默认情况下，<code>v-model</code> 在每次 <code>input</code> 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 <code>lazy</code> 修饰符，从而转为在 <code>change</code> 事件<strong>之后</strong>进行同步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span><br><span class="line">&lt;input v-model.lazy=&quot;msg&quot;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="number"><a href="#number" class="headerlink" title=".number"></a><p style="font-size:20px"><code>.number</code></p></h4><p>如果想自动将用户的输入值转为数值类型，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>这通常很有用，因为即使在 <code>type=&quot;number&quot;</code> 时，HTML 输入元素的值也总会返回字符串。</p>
<p>如果这个值无法被 <code>parseFloat()</code> 解析，则会返回原始的值。</p>
<h4 id="trim"><a href="#trim" class="headerlink" title=".trim"></a><p style="font-size:20px"><code>.trim</code></p></h4><p>如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.trim=&quot;msg&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h2><h4 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a><p style="font-size:20px">v-pre</p></h4><p><strong>用法</strong>： 不需要表达式，直接写在标签上</p>
<p><strong>介绍：</strong> 跳过这个元素和它的子元素的编译过程，可以用来显示原始 Mustache 标签，跳过大量没有指令的节点会加快编译。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Vue2-x-生命周期"><a href="#Vue2-x-生命周期" class="headerlink" title="Vue2.x 生命周期"></a>Vue2.x 生命周期</h1><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</p>
<p>比如 created 钩子可以用来在一个实例被创建之后执行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: 1</span><br><span class="line">  &#125;,</span><br><span class="line">  created: function () &#123;</span><br><span class="line">    // `this` 指向 vm 实例</span><br><span class="line">    console.log(&#x27;a is: &#x27; + this.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// =&gt; &quot;a is: 1&quot;</span><br></pre></td></tr></table></figure>

<p>也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 mounted、updated 和 destroyed。</p>
<p>生命周期钩子的 this 上下文指向调用它的 Vue 实例。</p>
<p>不要在选项 property 或回调上使用箭头函数，比如 created: () &#x3D;&gt; console.log(this.a) 或 vm.$watch(‘a’, newValue &#x3D;&gt; this.myMethod())。因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。</p>
<h2 id="钩子详细介绍"><a href="#钩子详细介绍" class="headerlink" title="钩子详细介绍"></a>钩子详细介绍</h2><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a><p style="font-size:20px">beforeCreate</p></h3><p><strong>类型</strong>：<code>Function</code></p>
<p><strong>详细</strong>：在实例初始化之后，数据观测 (data observer) 和 event&#x2F;watcher 事件配置之前被调用。</p>
<h3 id="created"><a href="#created" class="headerlink" title="created"></a><p style="font-size:20px">created</p></h3><p><strong>类型</strong>：<code>Function</code></p>
<p><strong>详细</strong>：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch&#x2F;event 事件回调。然而，挂载阶段还没开始，<code>$el</code> property 目前尚不可用。</p>
<h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a><p style="font-size:20px">beforeMount</p></h3><p><strong>类型</strong>：<code>Function</code></p>
<p><strong>详细</strong>：在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
<h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a><p style="font-size:20px">mounted</p></h3><p><strong>类型</strong>：<code>Function</code></p>
<p><strong>详细</strong>：实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。注意 mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mounted: function () &#123;</span><br><span class="line">  this.$nextTick(function () &#123;</span><br><span class="line">      // Code that will run only after the</span><br><span class="line">      // entire view has been rendered</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
<h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a><p style="font-size:20px">beforeUpdate</p></h3><p><strong>类型</strong>：<code>Function</code></p>
<p><strong>详细</strong>：数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</p>
<p><strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</strong></p>
<h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a><p style="font-size:20px">updated</p></h3><p><strong>类型</strong>：Function</p>
<p><strong>详细</strong>：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或监视器取而代之。注意 updated 不会保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 updated 里使用 vm.$nextTick：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">updated: function () &#123;</span><br><span class="line">  this.$nextTick(function () &#123;</span><br><span class="line">      // Code that will run only after the</span><br><span class="line">      // entire view has been re-rendered</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
<h3 id="activated"><a href="#activated" class="headerlink" title="activated"></a><p style="font-size:20px">activated</p></h3><p><strong>类型</strong>：<code>Function</code></p>
<p><strong>详细</strong>：被 keep-alive 缓存的组件激活时调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
<h3 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a><p style="font-size:20px">deactivated</p></h3><p><strong>类型</strong>：<code>Function</code></p>
<p><strong>详细</strong>：被 keep-alive 缓存的组件停用时调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
<h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a><p style="font-size:20px">beforeDestroy</p></h3><p><strong>类型</strong>：<code>Function</code></p>
<p><strong>详细</strong>：实例销毁之前调用。在这一步，实例仍然完全可用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
<h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a><p style="font-size:20px">destroyed</p></h3><p><strong>类型</strong>：<code>Function</code></p>
<p><strong>详细</strong>：实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
<h3 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a><p style="font-size:20px">errorCaptured</p></h3><p>2.5.0+ 新增</p>
<p><strong>类型</strong>：(err: Error, vm: Component, info: string) &#x3D;&gt; ?boolean</p>
<p><strong>类型</strong>：当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。你可以在此钩子中修改组件的状态。因此在捕获错误时，在模板或渲染函数中有一个条件判断来绕过其它内容就很重要；不然该组件可能会进入一个无限的渲染循环。</p>
<p><strong>错误传播规则</strong></p>
<pre><code>默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。
</code></pre>
<p>默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。</p>
<p>如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。</p>
<p>如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler。</p>
<p>一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler。</p>
<h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h2><p>下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。</p>
<img src="/2023/09/06/Vue2/fd8f100c078570cdcf7dfe0b7e28c5d2.png">

<h1 id="Vue2-x-过渡动画"><a href="#Vue2-x-过渡动画" class="headerlink" title="Vue2.x 过渡动画"></a>Vue2.x 过渡动画</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具：</p>
<p>在 CSS 过渡和动画中自动应用 class<br>可以配合使用第三方 CSS 动画库，如 Animate.css<br>在过渡钩子函数中使用 JavaScript 直接操作 DOM<br>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</p>
<h2 id="元素组件过渡和动画"><a href="#元素组件过渡和动画" class="headerlink" title="元素组件过渡和动画"></a>元素组件过渡和动画</h2><h3 id="过渡演示"><a href="#过渡演示" class="headerlink" title="过渡演示"></a><p style="font-size:20px">过渡演示</p></h3><p>Vue 提供了 <code>transition</code> 的封装组件，在下列情形中，可以给任何元素和组件添加进入&#x2F;离开过渡</p>
<ul>
<li>条件渲染 (使用 <code>v-if</code>)</li>
<li>条件展示 (使用 <code>v-show</code>)</li>
<li>动态组件</li>
<li>组件根节点</li>
</ul>
<p>这里是一个典型的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;show = !show&quot;&gt;</span><br><span class="line">    Toggle</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">  &lt;transition name=&quot;fade&quot;&gt;</span><br><span class="line">    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#demo&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.fade-enter-active, .fade-leave-active &#123;</span><br><span class="line">  transition: opacity .5s;</span><br><span class="line">&#125;</span><br><span class="line">.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理：
</code></pre>
<p>自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加&#x2F;删除 CSS 类名。</p>
<p>如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。</p>
<p>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡&#x2F;动画，DOM 操作 (插入&#x2F;删除) 在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和 Vue 的 nextTick 概念不同)</p>
<h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a><p style="font-size:20px">钩子函数</p></h3><p>可以在 attribute 中声明 JavaScript 钩子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">  v-on:before-enter=&quot;beforeEnter&quot;</span><br><span class="line">  v-on:enter=&quot;enter&quot;</span><br><span class="line">  v-on:after-enter=&quot;afterEnter&quot;</span><br><span class="line">  v-on:enter-cancelled=&quot;enterCancelled&quot;</span><br><span class="line"></span><br><span class="line">  v-on:before-leave=&quot;beforeLeave&quot;</span><br><span class="line">  v-on:leave=&quot;leave&quot;</span><br><span class="line">  v-on:after-leave=&quot;afterLeave&quot;</span><br><span class="line">  v-on:leave-cancelled=&quot;leaveCancelled&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;!-- ... --&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">methods: &#123;</span><br><span class="line">  // --------</span><br><span class="line">  // 进入中</span><br><span class="line">  // --------</span><br><span class="line"></span><br><span class="line">  beforeEnter: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  // 当与 CSS 结合使用时</span><br><span class="line">  // 回调函数 done 是可选的</span><br><span class="line">  enter: function (el, done) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    done()</span><br><span class="line">  &#125;,</span><br><span class="line">  afterEnter: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  enterCancelled: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // --------</span><br><span class="line">  // 离开时</span><br><span class="line">  // --------</span><br><span class="line"></span><br><span class="line">  beforeLeave: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  // 当与 CSS 结合使用时</span><br><span class="line">  // 回调函数 done 是可选的</span><br><span class="line">  leave: function (el, done) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    done()</span><br><span class="line">  &#125;,</span><br><span class="line">  afterLeave: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  // leaveCancelled 只用于 v-show 中</span><br><span class="line">  leaveCancelled: function (el) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些钩子函数可以结合 CSS transitions&#x2F;animations 使用，也可以单独使用。</p>
<p>当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。</p>
<p>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css&#x3D;”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</p>
<p>一个使用 Velocity.js 的简单例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;show = !show&quot;&gt;</span><br><span class="line">    Toggle</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">  &lt;transition</span><br><span class="line">    v-on:before-enter=&quot;beforeEnter&quot;</span><br><span class="line">    v-on:enter=&quot;enter&quot;</span><br><span class="line">    v-on:leave=&quot;leave&quot;</span><br><span class="line">    v-bind:css=&quot;false&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;p v-if=&quot;show&quot;&gt;</span><br><span class="line">      Demo</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#demo&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: false</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    beforeEnter: function (el) &#123;</span><br><span class="line">      el.style.opacity = 0</span><br><span class="line">      el.style.transformOrigin = &#x27;left&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    enter: function (el, done) &#123;</span><br><span class="line">      Velocity(el, &#123; opacity: 1, fontSize: &#x27;1.4em&#x27; &#125;, &#123; duration: 300 &#125;)</span><br><span class="line">      Velocity(el, &#123; fontSize: &#x27;1em&#x27; &#125;, &#123; complete: done &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    leave: function (el, done) &#123;</span><br><span class="line">      Velocity(el, &#123; translateX: &#x27;15px&#x27;, rotateZ: &#x27;50deg&#x27; &#125;, &#123; duration: 600 &#125;)</span><br><span class="line">      Velocity(el, &#123; rotateZ: &#x27;100deg&#x27; &#125;, &#123; loop: 2 &#125;)</span><br><span class="line">      Velocity(el, &#123;</span><br><span class="line">        rotateZ: &#x27;45deg&#x27;,</span><br><span class="line">        translateY: &#x27;30px&#x27;,</span><br><span class="line">        translateX: &#x27;30px&#x27;,</span><br><span class="line">        opacity: 0</span><br><span class="line">      &#125;, &#123; complete: done &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="过渡类名"><a href="#过渡类名" class="headerlink" title="过渡类名"></a><p style="font-size:20px">过渡类名</p></h3><p>在进入&#x2F;离开的过渡中，会有 6 个 class 切换。</p>
<p>v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。<br>v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡&#x2F;动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。<br>v-enter-to：2.1.8 版及以上定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡&#x2F;动画完成之后移除。<br>v-leave：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。<br>v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡&#x2F;动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。<br>v-leave-to：2.1.8 版及以上定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡&#x2F;动画完成之后移除。</p>
<img src="/2023/09/06/Vue2/8a49337fb55bca910d008ecc55fefcd4.png">

<p>对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 <transition>，则 v- 是这些类名的默认前缀。如果你使用了 <transition name="my-transition">，那么 v-enter 会替换为 my-transition-enter。</transition></transition></p>
<p>v-enter-active 和 v-leave-active 可以控制进入&#x2F;离开过渡的不同的缓和曲线，在下面章节会有个示例说明</p>
<h3 id="CSS-过渡"><a href="#CSS-过渡" class="headerlink" title="CSS 过渡"></a><p style="font-size:20px">CSS 过渡</p></h3><p>常用的过渡都是使用 CSS 过渡。</p>
<p>下面是一个简单例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;show = !show&quot;&gt;</span><br><span class="line">    Toggle render</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">  &lt;transition name=&quot;slide-fade&quot;&gt;</span><br><span class="line">    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#demo&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<img src="/2023/09/06/Vue2/af06799336ca95bac5cab0bad297341e.gif">

<h3 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS 动画"></a><p style="font-size:20px">CSS 动画</p></h3><p>CSS 动画用法同 CSS 过渡，区别是在动画中 <code>v-enter</code> 类名在节点插入 DOM 后不会立即删除，而是在 <code>animationend</code> 事件触发时删除。示例：(省略了兼容性前缀)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;show = !show&quot;&gt;Toggle show&lt;/button&gt;</span><br><span class="line">  &lt;transition name=&quot;bounce&quot;&gt;</span><br><span class="line">    &lt;p v-if=&quot;show&quot; style=&quot;display: inline-block&quot;&gt;Tom Love Jerry&lt;/p&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#demo&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.bounce-enter-active &#123;</span><br><span class="line">  animation: bounce-in .5s;</span><br><span class="line">&#125;</span><br><span class="line">.bounce-leave-active &#123;</span><br><span class="line">  animation: bounce-in .5s reverse;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes bounce-in &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    transform: scale(0);</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    transform: scale(1.5);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: scale(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/09/06/Vue2/e1e91b5c2f662b280875e3fc8350919b (1).gif">

<h3 id="自定义过渡的类名"><a href="#自定义过渡的类名" class="headerlink" title="自定义过渡的类名"></a><p style="font-size:20px">自定义过渡的类名</p></h3><p>我们可以通过以下 attribute 来自定义过渡类名：</p>
<ul>
<li><code>enter-class</code></li>
<li><code>enter-active-class</code></li>
<li><code>enter-to-class</code> (2.1.8+)</li>
<li><code>leave-class</code></li>
<li><code>leave-active-class</code></li>
<li><code>leave-to-class</code> (2.1.8+)</li>
</ul>
<p>他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 <a target="_blank" rel="noopener" href="https://daneden.github.io/animate.css/">Animate.css</a> 结合使用十分有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;https://cdn.jsdelivr.net/npm/animate.css@3.5.1&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;show = !show&quot;&gt;</span><br><span class="line">    Toggle render</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">  &lt;transition</span><br><span class="line">    name=&quot;custom-classes-transition&quot;</span><br><span class="line">    enter-active-class=&quot;animated tada&quot;</span><br><span class="line">    leave-active-class=&quot;animated bounceOutRight&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<img src="/2023/09/06/Vue2/9e54cfb2dfbd90e2e91a49aafe3a5b1a.gif">

<h3 id="同时使用过渡和动画"><a href="#同时使用过渡和动画" class="headerlink" title="同时使用过渡和动画"></a><p style="font-size:20px">同时使用过渡和动画</p></h3><p>Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。</p>
<p>但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type attribute 并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。</p>
<h3 id="显性的过渡持续时间"><a href="#显性的过渡持续时间" class="headerlink" title="显性的过渡持续时间"></a><p style="font-size:20px">显性的过渡持续时间</p></h3><p>2.2.0 新增</p>
<p>在很多情况下，Vue 可以自动得出过渡效果的完成时机。默认情况下，Vue 会等待其在过渡效果的根元素的第一个 transitionend 或 animationend 事件。然而也可以不这样设定，比如，我们可以拥有一个精心编排的一系列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果。</p>
<p>在这种情况下你可以用 <code>&lt;transition&gt;</code> 组件上的 <code>duration</code> prop 定制一个显性的过渡持续时间 (以毫秒计)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition :duration=&quot;1000&quot;&gt;...&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<p>你也可以定制进入和移出的持续时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition :duration=&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt;...&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<h2 id="多个元素过渡和动画"><a href="#多个元素过渡和动画" class="headerlink" title="多个元素过渡和动画"></a>多个元素过渡和动画</h2><p>我们之后讨论多个组件的过渡，对于原生标签可以使用 <code>v-if</code>&#x2F;<code>v-else</code>。</p>
<p>最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;table v-if=&quot;items.length &gt; 0&quot;&gt;</span><br><span class="line">    &lt;!-- ... --&gt;</span><br><span class="line">  &lt;/table&gt;</span><br><span class="line">  &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<p>可以这样使用，但是有一点需要注意：</p>
<p>当有相同标签名的元素切换时，需要通过 key attribute 设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 <transition> 组件中的多个元素设置 key 是一个更好的实践。</transition></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt;</span><br><span class="line">    Save</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">  &lt;button v-else key=&quot;edit&quot;&gt;</span><br><span class="line">    Edit</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<p>在一些场景中，也可以通过给同一个元素的 <code>key</code> attribute 设置不同的状态来代替 <code>v-if</code> 和 <code>v-else</code>，上面的例子可以重写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;button v-bind:key=&quot;isEditing&quot;&gt;</span><br><span class="line">    &#123;&#123; isEditing ? &#x27;Save&#x27; : &#x27;Edit&#x27; &#125;&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<p>使用多个 <code>v-if</code> 的多个元素的过渡可以重写为绑定了动态 property 的单个元素过渡。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;button v-if=&quot;docState === &#x27;saved&#x27;&quot; key=&quot;saved&quot;&gt;</span><br><span class="line">    Edit</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">  &lt;button v-if=&quot;docState === &#x27;edited&#x27;&quot; key=&quot;edited&quot;&gt;</span><br><span class="line">    Save</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">  &lt;button v-if=&quot;docState === &#x27;editing&#x27;&quot; key=&quot;editing&quot;&gt;</span><br><span class="line">    Cancel</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<p>可以重写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;button v-bind:key=&quot;docState&quot;&gt;</span><br><span class="line">    &#123;&#123; buttonMessage &#125;&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">computed: &#123;</span><br><span class="line">  buttonMessage: function () &#123;</span><br><span class="line">    switch (this.docState) &#123;</span><br><span class="line">      case &#x27;saved&#x27;: return &#x27;Edit&#x27;</span><br><span class="line">      case &#x27;edited&#x27;: return &#x27;Save&#x27;</span><br><span class="line">      case &#x27;editing&#x27;: return &#x27;Cancel&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还有一个问题，试着点击下面的按钮：</p>
<p>在“on”按钮和“off”按钮的过渡中，两个按钮都被重绘了，一个离开过渡的时候另一个开始进入过渡。</p>
<p>这是 <transition> 的默认行为 - 进入和离开同时发生。</transition></p>
<p>在元素绝对定位在彼此之上的时候运行正常：</p>
<p>然后，我们加上 translate 让它们运动像滑动过渡：</p>
<p>同时生效的进入和离开的过渡不能满足所有要求，所以 Vue 提供了过渡模式</p>
<p>in-out：新元素先进行过渡，完成之后当前元素过渡离开。<br>out-in：当前元素先进行过渡，完成之后新元素过渡进入。<br>用 out-in 重写之前的开关按钮过渡：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt;</span><br><span class="line">  &lt;!-- ... the buttons ... --&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<p>只用添加一个简单的 attribute，就解决了之前的过渡问题而无需任何额外的代码。</p>
<p><code>in-out</code> 模式不是经常用到，但对于一些稍微不同的过渡效果还是有用的。将之前滑动淡出的例子结合：</p>
<h2 id="多个组件过渡和动画"><a href="#多个组件过渡和动画" class="headerlink" title="多个组件过渡和动画"></a>多个组件过渡和动画</h2><p>注意：这个章节假设你已经对 <strong>Vue 组件</strong> 有一定的了解。当然你也可以先跳过这里，稍后再回过头来看。</p>
<p>多个组件的过渡简单很多 - 我们不需要使用 <code>key</code> attribute。相反，我们只需要使用<strong>动态组件</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        &lt;input type=&quot;radio&quot; v-model=&quot;view&quot; name=&quot;component&quot; value=&quot;v-a&quot; id=&quot;A&quot;&gt;</span><br><span class="line">        &lt;label for=&quot;A&quot;&gt;A&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;radio&quot; v-model=&quot;view&quot; name=&quot;component&quot; value=&quot;v-b&quot; id=&quot;B&quot;&gt;</span><br><span class="line">        &lt;label for=&quot;B&quot;&gt;B&lt;/label&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt;</span><br><span class="line">        &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">    &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#demo&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        view: &#x27;v-a&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        &#x27;v-a&#x27;: &#123;</span><br><span class="line">            template: &#x27;&lt;div&gt;Component A&lt;/div&gt;&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x27;v-b&#x27;: &#123;</span><br><span class="line">            template: &#x27;&lt;div&gt;Component B&lt;/div&gt;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.component-fade-enter-active, .component-fade-leave-active &#123;</span><br><span class="line">  transition: opacity .3s ease;</span><br><span class="line">&#125;</span><br><span class="line">.component-fade-enter, .component-fade-leave-to</span><br><span class="line">/* .component-fade-leave-active for below version 2.1.8 */ &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始渲染过渡"><a href="#初始渲染过渡" class="headerlink" title="初始渲染过渡"></a>初始渲染过渡</h2><p>可以通过 <code>appear</code> attribute 设置节点在初始渲染的过渡</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition appear&gt;</span><br><span class="line">  &lt;!-- ... --&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<p>这里默认和进入&#x2F;离开过渡一样，同样也可以自定义 CSS 类名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">  appear</span><br><span class="line">  appear-class=&quot;custom-appear-class&quot;</span><br><span class="line">  appear-to-class=&quot;custom-appear-to-class&quot; (2.1.8+)</span><br><span class="line">  appear-active-class=&quot;custom-appear-active-class&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;!-- ... --&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<p>自定义 JavaScript 钩子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">  appear</span><br><span class="line">  v-on:before-appear=&quot;customBeforeAppearHook&quot;</span><br><span class="line">  v-on:appear=&quot;customAppearHook&quot;</span><br><span class="line">  v-on:after-appear=&quot;customAfterAppearHook&quot;</span><br><span class="line">  v-on:appear-cancelled=&quot;customAppearCancelledHook&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;!-- ... --&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，无论是 <code>appear</code> attribute 还是 <code>v-on:appear</code> 钩子都会生成初始渲染过渡。</p>
<h2 id="列表过渡"><a href="#列表过渡" class="headerlink" title="列表过渡"></a>列表过渡</h2><h3 id="列表的过渡效果"><a href="#列表的过渡效果" class="headerlink" title="列表的过渡效果"></a><p style="font-size:20px">列表的过渡效果</p></h3><p>目前为止，关于过渡我们已经讲到：</p>
<p>单个节点<br>同一时间渲染多个节点中的一个<br>那么怎么同时渲染整个列表，比如使用 v-for？</p>
<p>在这种场景中，使用 <transition-group> 组件。</transition-group></p>
<p>在我们深入例子之前，先了解关于这个组件的几个特点：</p>
<p>不同于 <transition>，它会以一个真实元素呈现：默认为一个 <span>。你也可以通过 tag attribute 更换为其他元素。<br>过渡模式不可用，因为我们不再相互切换特有的元素。<br>内部元素总是需要提供唯一的 key attribute 值。<br>CSS 过渡的类将会应用在内部的元素中，而不是这个组&#x2F;容器本身。</span></transition></p>
<p>现在让我们由一个简单的例子深入，进入和离开的过渡使用之前一样的 CSS 类名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;remove&quot;&gt;Remove&lt;/button&gt;</span><br><span class="line">    &lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt;</span><br><span class="line">        &lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt;</span><br><span class="line">        	&#123;&#123; item &#125;&#125;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">    &lt;/transition-group&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#demo&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        items: [1, 2, 3, 4, 5, 6, 7, 8, 9],</span><br><span class="line">        nextNum: 10</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        randomIndex: function () &#123;</span><br><span class="line">            return Math.floor(Math.random() * this.items.length)</span><br><span class="line">        &#125;,</span><br><span class="line">        add: function () &#123;</span><br><span class="line">            this.items.splice(this.randomIndex(), 0, this.nextNum++)</span><br><span class="line">        &#125;,</span><br><span class="line">        remove: function () &#123;</span><br><span class="line">            this.items.splice(this.randomIndex(), 1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.list-item &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin-right: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.list-enter-active, .list-leave-active &#123;</span><br><span class="line">  transition: all 1s;</span><br><span class="line">&#125;</span><br><span class="line">.list-enter, .list-leave-to</span><br><span class="line">/* .list-leave-active for below version 2.1.8 */ &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">  transform: translateY(30px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子有个问题，当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，而不是平滑的过渡，我们下面会解决这个问题。</p>
<h3 id="列表的排序过渡"><a href="#列表的排序过渡" class="headerlink" title="列表的排序过渡"></a><p style="font-size:20px">列表的排序过渡</p></h3><p><transition-group> 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move class，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 name attribute 来自定义前缀，也可以通过 move-class attribute 手动设置。</transition-group></p>
<p>v-move 对于设置过渡的切换时机和过渡曲线非常有用，你会看到如下的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;shuffle&quot;&gt;Shuffle&lt;/button&gt;</span><br><span class="line">    &lt;transition-group name=&quot;flip-list&quot; tag=&quot;ul&quot;&gt;</span><br><span class="line">        &lt;li v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot;&gt;</span><br><span class="line">            &#123;&#123; item &#125;&#125;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    &lt;/transition-group&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#demo&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        items: [1,2,3,4,5,6,7,8,9]</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        shuffle: function () &#123;</span><br><span class="line">            this.items = _.shuffle(this.items)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.flip-list-move &#123;</span><br><span class="line">  transition: transform 1s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> 这个看起来很神奇，内部的实现，Vue 使用了一个叫 <a target="_blank" rel="noopener" href="https://aerotwist.com/blog/flip-your-animations/">FLIP</a> 简单的动画队列，使用 transforms 将元素从之前的位置平滑过渡新的位置。</p>
<p>我们将之前实现的例子和这个技术结合，使我们列表的一切变动都会有动画过渡。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;shuffle&quot;&gt;Shuffle&lt;/button&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;add&quot;&gt;Add&lt;/button&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;remove&quot;&gt;Remove&lt;/button&gt;</span><br><span class="line">    &lt;transition-group name=&quot;list-complete&quot; tag=&quot;p&quot;&gt;</span><br><span class="line">    &lt;span</span><br><span class="line">        v-for=&quot;item in items&quot;</span><br><span class="line">        v-bind:key=&quot;item&quot;</span><br><span class="line">        class=&quot;list-complete-item&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;/transition-group&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#demo&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        items: [1,2,3,4,5,6,7,8,9],</span><br><span class="line">        nextNum: 10</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        randomIndex: function () &#123;</span><br><span class="line">            return Math.floor(Math.random() * this.items.length)</span><br><span class="line">        &#125;,</span><br><span class="line">        add: function () &#123;</span><br><span class="line">            this.items.splice(this.randomIndex(), 0, this.nextNum++)</span><br><span class="line">        &#125;,</span><br><span class="line">        remove: function () &#123;</span><br><span class="line">            this.items.splice(this.randomIndex(), 1)</span><br><span class="line">        &#125;,</span><br><span class="line">        shuffle: function () &#123;</span><br><span class="line">            this.items = _.shuffle(this.items)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.list-complete-item &#123;</span><br><span class="line">  transition: all 1s;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  margin-right: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.list-complete-enter, .list-complete-leave-to</span><br><span class="line">/* .list-complete-leave-active for below version 2.1.8 */ &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">  transform: translateY(30px);</span><br><span class="line">&#125;</span><br><span class="line">.list-complete-leave-active &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是使用 FLIP 过渡的元素不能设置为 <code>display: inline</code> 。</p>
<p>作为替代方案，可以设置为 <code>display: inline-block</code> 或者放置于 flex 中。</p>
<p>FLIP 动画不仅可以实现单列过渡，多维网格也<a target="_blank" rel="noopener" href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-list-move-transitions">同样可以过渡</a>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">    &lt;h1&gt;Lazy Sudoku&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Keep hitting the shuffle button until you win.&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;shuffle&quot;&gt;</span><br><span class="line">        Shuffle</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">    &lt;transition-group name=&quot;cell&quot; tag=&quot;div&quot; class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;div v-for=&quot;cell in cells&quot; :key=&quot;cell.id&quot; class=&quot;cell&quot;&gt;</span><br><span class="line">            &#123;&#123; cell.number &#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/transition-group&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#demo&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        cells: Array.apply(null, &#123;length: 81&#125;).map(function (_, index) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                id: index,</span><br><span class="line">                number: (index % 9) + 1</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        shuffle: function () &#123;</span><br><span class="line">            this.cells = _.shuffle(this.cells);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">    width: 238px;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.cell &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: space-around;</span><br><span class="line">    align-items: center;</span><br><span class="line">    width: 25px;</span><br><span class="line">    height: 25px;</span><br><span class="line">    border: 1px solid #aaa;</span><br><span class="line">    margin-right: -1px;</span><br><span class="line">    margin-bottom: -1px;</span><br><span class="line">&#125;</span><br><span class="line">.cell:nth-child(3n) &#123;</span><br><span class="line">    margin-right: 0;</span><br><span class="line">&#125;</span><br><span class="line">.cell:nth-child(27n) &#123;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line">.cell-move &#123;</span><br><span class="line">    transition: transform 1s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="列表的交错过渡"><a href="#列表的交错过渡" class="headerlink" title="列表的交错过渡"></a><p style="font-size:20px">列表的交错过渡</p></h3><p>通过 data attribute 与 JavaScript 通信，就可以实现列表的交错过渡：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">    &lt;input v-model=&quot;query&quot;&gt;</span><br><span class="line">    &lt;transition-group</span><br><span class="line">        name=&quot;staggered-fade&quot;</span><br><span class="line">        tag=&quot;ul&quot;</span><br><span class="line">        v-bind:css=&quot;false&quot;</span><br><span class="line">        v-on:before-enter=&quot;beforeEnter&quot;</span><br><span class="line">        v-on:enter=&quot;enter&quot;</span><br><span class="line">        v-on:leave=&quot;leave&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;li</span><br><span class="line">            v-for=&quot;(item, index) in computedList&quot;</span><br><span class="line">            v-bind:key=&quot;item.msg&quot;</span><br><span class="line">            v-bind:data-index=&quot;index&quot;</span><br><span class="line">        &gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/transition-group&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">    &lt;input v-model=&quot;query&quot;&gt;</span><br><span class="line">    &lt;transition-group</span><br><span class="line">        name=&quot;staggered-fade&quot;</span><br><span class="line">        tag=&quot;ul&quot;</span><br><span class="line">        v-bind:css=&quot;false&quot;</span><br><span class="line">        v-on:before-enter=&quot;beforeEnter&quot;</span><br><span class="line">        v-on:enter=&quot;enter&quot;</span><br><span class="line">        v-on:leave=&quot;leave&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;li</span><br><span class="line">            v-for=&quot;(item, index) in computedList&quot;</span><br><span class="line">            v-bind:key=&quot;item.msg&quot;</span><br><span class="line">            v-bind:data-index=&quot;index&quot;</span><br><span class="line">        &gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/transition-group&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="可复用过渡"><a href="#可复用过渡" class="headerlink" title="可复用过渡"></a>可复用过渡</h2><p>注意：这个章节假设你已经对 <strong>Vue 组件</strong> 有一定的了解。当然你也可以先跳过这里，稍后再回过头来看。</p>
<p>过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将 <code>&lt;transition&gt;</code> 或者 <code>&lt;transition-group&gt;</code> 作为根组件，然后将任何子组件放置在其中就可以了。</p>
<p>使用 template 的简单例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;my-special-transition&#x27;, &#123;</span><br><span class="line">  template: &#x27;\</span><br><span class="line">    &lt;transition\</span><br><span class="line">      name=&quot;very-special-transition&quot;\</span><br><span class="line">      mode=&quot;out-in&quot;\</span><br><span class="line">      v-on:before-enter=&quot;beforeEnter&quot;\</span><br><span class="line">      v-on:after-enter=&quot;afterEnter&quot;\</span><br><span class="line">    &gt;\</span><br><span class="line">      &lt;slot&gt;&lt;/slot&gt;\</span><br><span class="line">    &lt;/transition&gt;\</span><br><span class="line">  &#x27;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    beforeEnter: function (el) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;,</span><br><span class="line">    afterEnter: function (el) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>函数式组件更适合完成这个任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;my-special-transition&#x27;, &#123;</span><br><span class="line">  functional: true,</span><br><span class="line">  render: function (createElement, context) &#123;</span><br><span class="line">    var data = &#123;</span><br><span class="line">      props: &#123;</span><br><span class="line">        name: &#x27;very-special-transition&#x27;,</span><br><span class="line">        mode: &#x27;out-in&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      on: &#123;</span><br><span class="line">        beforeEnter: function (el) &#123;</span><br><span class="line">          // ...</span><br><span class="line">        &#125;,</span><br><span class="line">        afterEnter: function (el) &#123;</span><br><span class="line">          // ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return createElement(&#x27;transition&#x27;, data, context.children)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="动态过渡"><a href="#动态过渡" class="headerlink" title="动态过渡"></a>动态过渡</h2><p>在 Vue 中即使是过渡也是数据驱动的！动态过渡最基本的例子是通过 <code>name</code> attribute 来绑定动态值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition v-bind:name=&quot;transitionName&quot;&gt;</span><br><span class="line">  &lt;!-- ... --&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>

<p>当你想用 Vue 的过渡系统来定义的 CSS 过渡&#x2F;动画在不同过渡间切换会非常有用。</p>
<p>所有过渡 attribute 都可以动态绑定，但我们不仅仅只有 attribute 可以利用，还可以通过事件钩子获取上下文中的所有数据，因为事件钩子都是方法。这意味着，根据组件的状态不同，你的 JavaScript 过渡会有不同的表现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">    Fade In: &lt;input type=&quot;range&quot; v-model=&quot;fadeInDuration&quot; min=&quot;0&quot; v-bind:max=&quot;maxFadeDuration&quot;&gt;</span><br><span class="line">    Fade Out: &lt;input type=&quot;range&quot; v-model=&quot;fadeOutDuration&quot; min=&quot;0&quot; v-bind:max=&quot;maxFadeDuration&quot;&gt;</span><br><span class="line">    &lt;transition</span><br><span class="line">        v-bind:css=&quot;false&quot;</span><br><span class="line">        v-on:before-enter=&quot;beforeEnter&quot;</span><br><span class="line">        v-on:enter=&quot;enter&quot;</span><br><span class="line">        v-on:leave=&quot;leave&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class="line">    &lt;/transition&gt;</span><br><span class="line">    &lt;button</span><br><span class="line">        v-if=&quot;stop&quot;</span><br><span class="line">        v-on:click=&quot;stop = false; show = false&quot;</span><br><span class="line">    &gt;Start animating</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">    &lt;button</span><br><span class="line">        v-else</span><br><span class="line">        v-on:click=&quot;stop = true&quot;</span><br><span class="line">    &gt;Stop it!</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#demo&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        show: true,</span><br><span class="line">        fadeInDuration: 1000,</span><br><span class="line">        fadeOutDuration: 1000,</span><br><span class="line">        maxFadeDuration: 1500,</span><br><span class="line">        stop: true</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted: function () &#123;</span><br><span class="line">        this.show = false</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        beforeEnter: function (el) &#123;</span><br><span class="line">            el.style.opacity = 0</span><br><span class="line">        &#125;,</span><br><span class="line">        enter: function (el, done) &#123;</span><br><span class="line">            var vm = this</span><br><span class="line">            Velocity(el,</span><br><span class="line">                &#123;opacity: 1&#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    duration: this.fadeInDuration,</span><br><span class="line">                    complete: function () &#123;</span><br><span class="line">                        done()</span><br><span class="line">                        if (!vm.stop) vm.show = false</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;,</span><br><span class="line">        leave: function (el, done) &#123;</span><br><span class="line">            var vm = this</span><br><span class="line">            Velocity(el,</span><br><span class="line">                &#123;opacity: 0&#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    duration: this.fadeOutDuration,</span><br><span class="line">                    complete: function () &#123;</span><br><span class="line">                        done()</span><br><span class="line">                        vm.show = true</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最后，创建动态过渡的最终方案是组件通过接受 props 来动态修改之前的过渡。一句老话，唯一的限制是你的想象力。</p>
<h2 id="状态过渡"><a href="#状态过渡" class="headerlink" title="状态过渡"></a>状态过渡</h2><p>Vue 的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。</p>
<p>那么对于数据元素本身的动效呢，比如：</p>
<ul>
<li>数字和运算</li>
<li>颜色的显示</li>
<li>SVG 节点的位置</li>
<li>元素的大小和其他的 property</li>
</ul>
<p>这些数据要么本身就以数值形式存储，要么可以转换为数值。有了这些数值后，我们就可以结合 Vue 的响应式和组件系统，使用第三方库来实现切换元素的过渡状态。</p>
<h3 id="动态状态与侦听器"><a href="#动态状态与侦听器" class="headerlink" title="动态状态与侦听器"></a><p style="font-size:20px">动态状态与侦听器</p></h3><p>通过侦听器我们能监听到任何数值 property 的数值更新。可能听起来很抽象，所以让我们先来看看使用 <a target="_blank" rel="noopener" href="https://greensock.com/">GreenSock</a> 一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/gsap/3.2.4/gsap.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;animated-number-demo&quot;&gt;</span><br><span class="line">        &lt;input v-model.number=&quot;number&quot; type=&quot;number&quot; step=&quot;20&quot;&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123; animatedNumber &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#demo&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        number: 0,</span><br><span class="line">        tweenedNumber: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        animatedNumber: function() &#123;</span><br><span class="line">            return this.tweenedNumber.toFixed(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        number: function(newValue) &#123;</span><br><span class="line">            gsap.to(this.$data, &#123; duration: 0.5, tweenedNumber: newValue &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当你把数值更新时，就会触发动画。这个是一个不错的演示，但是对于不能直接像数字一样存储的值，比如 CSS 中的 color 的值，通过下面的例子我们来通过 <a target="_blank" rel="noopener" href="https://github.com/tweenjs/tween.js">Tween.js</a> 和 <a target="_blank" rel="noopener" href="https://github.com/brehaut/color-js">Color.js</a> 实现一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/tween.js@16.3.4&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/color-js@1.0.3&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">        v-model=&quot;colorQuery&quot;</span><br><span class="line">        v-on:keyup.enter=&quot;updateColor&quot;</span><br><span class="line">        placeholder=&quot;Enter a color&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;button v-on:click=&quot;updateColor&quot;&gt;Update&lt;/button&gt;</span><br><span class="line">    &lt;p&gt;Preview:&lt;/p&gt;</span><br><span class="line">    &lt;span</span><br><span class="line">        v-bind:style=&quot;&#123; backgroundColor: tweenedCSSColor &#125;&quot;</span><br><span class="line">        class=&quot;demo-color-preview&quot;</span><br><span class="line">    &gt;&lt;/span&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; tweenedCSSColor &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">var Color = net.brehaut.Color</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#demo&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        colorQuery: &#x27;&#x27;,</span><br><span class="line">        color: &#123;</span><br><span class="line">            red: 0,</span><br><span class="line">            green: 0,</span><br><span class="line">            blue: 0,</span><br><span class="line">            alpha: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        tweenedColor: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created: function () &#123;</span><br><span class="line">        this.tweenedColor = Object.assign(&#123;&#125;, this.color)</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        color: function () &#123;</span><br><span class="line">            function animate () &#123;</span><br><span class="line">                if (TWEEN.update()) &#123;</span><br><span class="line">                    requestAnimationFrame(animate)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            new TWEEN.Tween(this.tweenedColor)</span><br><span class="line">                .to(this.color, 750)</span><br><span class="line">                .start()</span><br><span class="line"></span><br><span class="line">            animate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        tweenedCSSColor: function () &#123;</span><br><span class="line">            return new Color(&#123;</span><br><span class="line">                red: this.tweenedColor.red,</span><br><span class="line">                green: this.tweenedColor.green,</span><br><span class="line">                blue: this.tweenedColor.blue,</span><br><span class="line">                alpha: this.tweenedColor.alpha</span><br><span class="line">            &#125;).toCSS()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        updateColor: function () &#123;</span><br><span class="line">            this.color = new Color(this.colorQuery).toRGB()</span><br><span class="line">            this.colorQuery = &#x27;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="动态状态过渡效果"><a href="#动态状态过渡效果" class="headerlink" title="动态状态过渡效果"></a><p style="font-size:20px">动态状态过渡效果</p></h3><p>就像 Vue 的过渡组件一样，数据背后状态过渡会实时更新，这对于原型设计十分有用。</p>
<p>当你修改一些变量，即使是一个简单的 SVG 多边形也可实现很多难以想象的效果。</p>
<p>上述 demo 背后的代码可以通过<a target="_blank" rel="noopener" href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-state-transitions">这个示例</a>进行详阅。</p>
<h3 id="把过渡放到组件里"><a href="#把过渡放到组件里" class="headerlink" title="把过渡放到组件里"></a><p style="font-size:20px">把过渡放到组件里</p></h3><p>注意：这个章节假设你已经对 <strong>Vue 组件</strong> 有一定的了解。当然你也可以先跳过这里，稍后再回过头来看。</p>
<p>管理太多的状态过渡会很快的增加 Vue 实例或者组件的复杂性，幸好很多的动画可以提取到专用的子组件。</p>
<p>我们来将之前的示例改写一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/tween.js@16.3.4&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">  &lt;input v-model.number=&quot;firstNumber&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; +</span><br><span class="line">  &lt;input v-model.number=&quot;secondNumber&quot; type=&quot;number&quot; step=&quot;20&quot;&gt; =</span><br><span class="line">  &#123;&#123; result &#125;&#125;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;animated-integer v-bind:value=&quot;firstNumber&quot;&gt;&lt;/animated-integer&gt; +</span><br><span class="line">    &lt;animated-integer v-bind:value=&quot;secondNumber&quot;&gt;&lt;/animated-integer&gt; =</span><br><span class="line">    &lt;animated-integer v-bind:value=&quot;result&quot;&gt;&lt;/animated-integer&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">// 这种复杂的补间动画逻辑可以被复用</span><br><span class="line">// 任何整数都可以执行动画</span><br><span class="line">// 组件化使我们的界面十分清晰</span><br><span class="line">// 可以支持更多更复杂的动态过渡</span><br><span class="line">// 策略。</span><br><span class="line">Vue.component(&#x27;animated-integer&#x27;, &#123;</span><br><span class="line">  template: &#x27;&lt;span&gt;&#123;&#123; tweeningValue &#125;&#125;&lt;/span&gt;&#x27;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      tweeningValue: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    value: function (newValue, oldValue) &#123;</span><br><span class="line">      this.tween(oldValue, newValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted: function () &#123;</span><br><span class="line">    this.tween(0, this.value)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    tween: function (startValue, endValue) &#123;</span><br><span class="line">      var vm = this</span><br><span class="line">      function animate () &#123;</span><br><span class="line">        if (TWEEN.update()) &#123;</span><br><span class="line">          requestAnimationFrame(animate)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      new TWEEN.Tween(&#123; tweeningValue: startValue &#125;)</span><br><span class="line">        .to(&#123; tweeningValue: endValue &#125;, 500)</span><br><span class="line">        .onUpdate(function () &#123;</span><br><span class="line">          vm.tweeningValue = this.tweeningValue.toFixed(0)</span><br><span class="line">        &#125;)</span><br><span class="line">        .start()</span><br><span class="line"></span><br><span class="line">      animate()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 所有的复杂度都已经从 Vue 的主实例中移除！</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#demo&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstNumber: 20,</span><br><span class="line">    secondNumber: 40</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    result: function () &#123;</span><br><span class="line">      return this.firstNumber + this.secondNumber</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们能在组件中结合使用这一节讲到各种过渡策略和 Vue 内建的过渡系统。总之，对于完成各种过渡动效几乎没有阻碍。</p>
<h1 id="Vue2-x-过滤器"><a href="#Vue2-x-过滤器" class="headerlink" title="Vue2.x 过滤器"></a>Vue2.x 过滤器</h1><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：<strong>双花括号插值和 v-bind 表达式</strong> (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在双花括号中 --&gt;</span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在 `v-bind` 中 --&gt;</span><br><span class="line">&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你可以在一个组件的选项中定义本地的过滤器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  capitalize: function (value) &#123;</span><br><span class="line">    if (!value) return &#x27;&#x27;</span><br><span class="line">    value = value.toString()</span><br><span class="line">    return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者在创建 Vue 实例之前全局定义过滤器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(&#x27;capitalize&#x27;, function (value) &#123;</span><br><span class="line">  if (!value) return &#x27;&#x27;</span><br><span class="line">  value = value.toString()</span><br><span class="line">  return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当全局过滤器和局部过滤器重名时，会采用局部过滤器。</p>
<p>下面这个例子用到了 <code>capitalize</code> 过滤器：</p>
<p>过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。</p>
<p>在上述例子中，<code>capitalize</code> 过滤器函数将会收到 <code>message</code> 的值作为第一个参数。</p>
<p>过滤器可以串联</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。</p>
<p>然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。</p>
<p>过滤器是 JavaScript 函数，因此可以接收参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA(&#x27;arg1&#x27;, arg2) &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>filterA</code> 被定义为接收三个参数的过滤器函数。其中 <code>message</code> 的值作为第一个参数，普通字符串 <code>&#39;arg1&#39;</code> 作为第二个参数，表达式 <code>arg2</code> 的值作为第三个参数。</p>
<h1 id="Vue2-x-网络请求"><a href="#Vue2-x-网络请求" class="headerlink" title="Vue2.x 网络请求"></a>Vue2.x 网络请求</h1><h2 id="vue-resource"><a href="#vue-resource" class="headerlink" title="vue-resource"></a>vue-resource</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a><p style="font-size:20px">概述</p></h3><p>vue 插件，非官方库，1.x 使用广泛</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a><p style="font-size:20px">文档</p></h3><p>文档地址：<a target="_blank" rel="noopener" href="https://github.com/pagekit/vue-resource/blob/develop/docs/http.md">https://github.com/pagekit/vue-resource/blob/develop/docs/http.md</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><p style="font-size:20px">安装</p></h3><p>npm 安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save vue vue-resource</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import VueResource from &#x27;vue-resource&#x27;</span><br><span class="line"></span><br><span class="line">Vue.use(VueResource)</span><br></pre></td></tr></table></figure>

<p>cdn 安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue-resource/1.5.1/vue-resource.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试接口：<a target="_blank" rel="noopener" href="https://api.github.com/search/repositories?q=vue&sort=stars">https://api.github.com/search/repositories?q=vue&amp;sort=stars</a></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><p style="font-size:20px">示例</p></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// global Vue object</span><br><span class="line">Vue.http.get(&#x27;/someUrl&#x27;, [config]).then(successCallback, errorCallback);</span><br><span class="line">Vue.http.post(&#x27;/someUrl&#x27;, [data], [config]).then(successCallback, errorCallback);</span><br><span class="line"></span><br><span class="line">// in a Vue instance</span><br><span class="line">this.$http.get(&#x27;/someUrl&#x27;, [config]).then(successCallback, errorCallback);</span><br><span class="line">this.$http.post(&#x27;/someUrl&#x27;, [data], [config]).then(successCallback, errorCallback);</span><br></pre></td></tr></table></figure>

<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a><p style="font-size:20px">概述</p></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save axios</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cdn 安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.21.0/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试接口：<a target="_blank" rel="noopener" href="https://api.github.com/search/repositories?q=vue&sort=stars">https://api.github.com/search/repositories?q=vue&amp;sort=stars</a></p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><p style="font-size:20px">示例</p></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// GET</span><br><span class="line">axios.get(url, [config])</span><br><span class="line">    .then(response =&gt; &#123;</span><br><span class="line">        console.log(response.data)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(error =&gt; &#123;</span><br><span class="line">        console.log(error.message)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">// POST</span><br><span class="line">axios.post(url, [data], [config])</span><br><span class="line">    .then(response =&gt; &#123;</span><br><span class="line">        console.log(response.data)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(error =&gt; &#123;</span><br><span class="line">        console.log(error.message)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Vue2-x-组件学习"><a href="#Vue2-x-组件学习" class="headerlink" title="Vue2.x 组件学习"></a>Vue2.x 组件学习</h1><h2 id="组件的示例"><a href="#组件的示例" class="headerlink" title="组件的示例"></a>组件的示例</h2><p>这里有一个 Vue 组件的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个名为 button-counter 的新组件</span><br><span class="line">Vue.component(&#x27;button-counter&#x27;, &#123;</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 <code>&lt;button-counter&gt;</code>。我们可以在一个通过 <code>new Vue</code> 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;components-demo&quot;&gt;</span><br><span class="line">  &lt;button-counter&gt;&lt;/button-counter&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123; el: &#x27;#components-demo&#x27; &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为组件是可复用的 Vue 实例，所以它们与 <code>new Vue</code> 接收相同的选项，例如 <code>data</code>、<code>computed</code>、<code>watch</code>、<code>methods</code> 以及生命周期钩子等。仅有的例外是像 <code>el</code> 这样根实例特有的选项。</p>
<h2 id="组件的复用"><a href="#组件的复用" class="headerlink" title="组件的复用"></a>组件的复用</h2><p>你可以将组件进行任意次数的复用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;components-demo&quot;&gt;</span><br><span class="line">  &lt;button-counter&gt;&lt;/button-counter&gt;</span><br><span class="line">  &lt;button-counter&gt;&lt;/button-counter&gt;</span><br><span class="line">  &lt;button-counter&gt;&lt;/button-counter&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123; el: &#x27;#components-demo&#x27; &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当我们定义这个 <code>&lt;button-counter&gt;</code> 组件时，你可能会发现它的 <code>data</code> 并不是像这样直接提供一个对象：</p>
<p>取而代之的是，<strong>一个组件的 data 选项必须是一个函数</strong>，因此每个实例可以维护一份被返回对象的独立的拷贝：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果 Vue 没有这条规则，点击一个按钮就可能会像如下代码一样影响到其它所有实例：</p>
<h2 id="组件的组织"><a href="#组件的组织" class="headerlink" title="组件的组织"></a>组件的组织</h2>  <img src="/2023/09/06/Vue2/ab9108e4391cd8aaf6c2eb9d064ba549.png">

<p>例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。</p>
<p>为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。</p>
<p>这里有两种组件的注册类型：全局注册和局部注册。</p>
<p>至此，我们的组件都只是通过 Vue.component 全局注册的：</p>
<p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;my-component-name&#x27;, &#123;</span><br><span class="line">  // ... options ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>全局注册的组件可以用在其被注册之后的任何 (通过 <code>new Vue</code>) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。</p>
<h2 id="组件的注册"><a href="#组件的注册" class="headerlink" title="组件的注册"></a>组件的注册</h2><p>​	</p>
<h3 id="组件名称"><a href="#组件名称" class="headerlink" title="组件名称"></a><p style="font-size:20px">组件名称</p></h3><p>在注册一个组件的时候，我们始终需要给它一个名字。比如在全局注册的时候我们已经看到了：</p>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;my-component-name&#x27;, &#123; /* ... */ &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该组件名就是 Vue.component 的第一个参数。</p>
<p>你给予组件的名字可能依赖于你打算拿它来做什么。当直接在 DOM 中使用一个组件 (而不是在字符串模板或单文件组件) 的时候，我们强烈推荐遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。</p>
<p>定义组件名的方式有两种：</p>
<p><strong>使用 kebab-case</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;my-component-name&#x27;, &#123; /* ... */ &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 <code>&lt;my-component-name&gt;</code>。</p>
<p><strong>使用 PascalCase</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;MyComponentName&#x27;, &#123; /* ... */ &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 <my-component-name> 和 <MyComponentName> 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。</MyComponentName></my-component-name></p>
<h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a><p style="font-size:20px">全局注册</p></h3><p>到目前为止，我们只用过 <code>Vue.component</code> 来创建组件：</p>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;my-component-name&#x27;, &#123;</span><br><span class="line">  // ... 选项 ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这些组件是<strong>全局注册的</strong>。也就是说它们在注册之后可以用在任何新创建的 Vue 根实例 (<code>new Vue</code>) 的模板中。比如：</p>
<p>​	   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;component-a&#x27;, &#123; /* ... */ &#125;)</span><br><span class="line">Vue.component(&#x27;component-b&#x27;, &#123; /* ... */ &#125;)</span><br><span class="line">Vue.component(&#x27;component-c&#x27;, &#123; /* ... */ &#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123; el: &#x27;#app&#x27; &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;component-a&gt;&lt;/component-a&gt;</span><br><span class="line">  &lt;component-b&gt;&lt;/component-b&gt;</span><br><span class="line">  &lt;component-c&gt;&lt;/component-c&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在所有子组件中也是如此，也就是说这三个组件<strong>在各自内部</strong>也都可以相互使用。</p>
<h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a><p style="font-size:20px">局部注册</p></h3><p>全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。</p>
<p>在这些情况下，你可以通过一个普通的 JavaScript 对象来定义组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let ComponentA = &#123; /* ... */ &#125;</span><br><span class="line">let ComponentB = &#123; /* ... */ &#125;</span><br><span class="line">let ComponentC = &#123; /* ... */ &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在 <code>components</code> 选项中定义你想要使用的组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &#x27;component-a&#x27;: ComponentA,</span><br><span class="line">    &#x27;component-b&#x27;: ComponentB,</span><br><span class="line">    &#x27;component-c&#x27;: ComponentC</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>对于 components 对象中的每个 property 来说，其 property 名就是自定义元素的名字，其 property 值就是这个组件的选项对象。</p>
<p>注意<strong>局部注册的组件在其子组件中不可用</strong>。</p>
<p>例如，如果你希望 ComponentA 在 ComponentB 中可用，则你需要这样写：</p>
<p>​				</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let ComponentA = &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">let ComponentB = &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    &#x27;component-a&#x27;: ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​						</p>
<p>或者如果你通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像：</p>
<p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import ComponentA from &#x27;./ComponentA.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在 ES2015+ 中，在对象中放一个类似 <code>ComponentA</code> 的变量名其实是 <code>ComponentA: ComponentA</code> 的缩写，即这个变量名同时是：</p>
<ul>
<li>用在模板中的自定义元素的名称</li>
<li>包含了这个组件选项的变量名</li>
</ul>
<h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a><p style="font-size:20px">模块系统</p></h3><p>如果你没有通过 import&#x2F;require 使用一个模块系统，也许可以暂且跳过这个章节。</p>
<p>如果你使用了，那么我们会为你提供一些特殊的使用说明和注意事项。</p>
<p>如果你还在阅读，说明你使用了诸如 Babel 和 webpack 的模块系统。</p>
<p>在这些情况下，我们推荐创建一个 components 目录，并将每个组件放置在其各自的文件中。</p>
<p>然后你需要在局部注册之前导入每个你想使用的组件。例如，在一个假设的 ComponentB.js 或 ComponentB.vue 文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import ComponentA from &#x27;./ComponentA&#x27;</span><br><span class="line">import ComponentC from &#x27;./ComponentC&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA,</span><br><span class="line">    ComponentC</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在 ComponentA 和 ComponentC 都可以在 ComponentB 的模板中使用了。</p>
<p>可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。</p>
<p>我们有时候会把它们称为基础组件，它们会在各个组件中被频繁的用到。</p>
<p>所以会导致很多组件里都会有一个包含基础组件的长列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import BaseButton from &#x27;./BaseButton.vue&#x27;</span><br><span class="line">import BaseIcon from &#x27;./BaseIcon.vue&#x27;</span><br><span class="line">import BaseInput from &#x27;./BaseInput.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    BaseButton,</span><br><span class="line">    BaseIcon,</span><br><span class="line">    BaseInput</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而只是用于模板中的一小部分：</p>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;BaseInput</span><br><span class="line">  v-model=&quot;searchText&quot;</span><br><span class="line">  @keydown.enter=&quot;search&quot;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;BaseButton @click=&quot;search&quot;&gt;</span><br><span class="line">  &lt;BaseIcon name=&quot;search&quot;/&gt;</span><br><span class="line">&lt;/BaseButton&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你恰好使用了 webpack (或在内部使用了 webpack 的 <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-cli">Vue CLI 3+</a>)，那么就可以使用 <code>require.context</code> 只全局注册这些非常通用的基础组件。这里有一份可以让你在应用入口文件 (比如 <code>src/main.js</code>) 中全局导入基础组件的示例代码：</p>
<p>​			</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import upperFirst from &#x27;lodash/upperFirst&#x27;</span><br><span class="line">import camelCase from &#x27;lodash/camelCase&#x27;</span><br><span class="line"></span><br><span class="line">const requireComponent = require.context(</span><br><span class="line">  // 其组件目录的相对路径</span><br><span class="line">  &#x27;./components&#x27;,</span><br><span class="line">  // 是否查询其子目录</span><br><span class="line">  false,</span><br><span class="line">  // 匹配基础组件文件名的正则表达式</span><br><span class="line">  /Base[A-Z]\w+\.(vue|js)$/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(fileName =&gt; &#123;</span><br><span class="line">  // 获取组件配置</span><br><span class="line">  const componentConfig = requireComponent(fileName)</span><br><span class="line"></span><br><span class="line">  // 获取组件的 PascalCase 命名</span><br><span class="line">  const componentName = upperFirst(</span><br><span class="line">    camelCase(</span><br><span class="line">      // 获取和目录深度无关的文件名</span><br><span class="line">      fileName</span><br><span class="line">        .split(&#x27;/&#x27;)</span><br><span class="line">        .pop()</span><br><span class="line">        .replace(/\.\w+$/, &#x27;&#x27;)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  // 全局注册组件</span><br><span class="line">  Vue.component(</span><br><span class="line">    componentName,</span><br><span class="line">    // 如果这个组件选项是通过 `export default` 导出的，</span><br><span class="line">    // 那么就会优先使用 `.default`，</span><br><span class="line">    // 否则回退到使用模块的根。</span><br><span class="line">    componentConfig.default || componentConfig</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>记住<strong>全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生</strong>。<a target="_blank" rel="noopener" href="https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js">这里</a>有一个真实项目情景下的示例。</p>
<h2 id="向子组件传递数据"><a href="#向子组件传递数据" class="headerlink" title="向子组件传递数据"></a>向子组件传递数据</h2><h3 id="Prop-入门"><a href="#Prop-入门" class="headerlink" title="Prop 入门"></a><p style="font-size:20px">Prop 入门</p></h3><p>早些时候，我们提到了创建一个博文组件的事情。问题是如果你不能向这个组件传递某一篇博文的标题或内容之类的我们想展示的数据的话，它是没有办法使用的。这也正是 prop 的由来。</p>
<p>Prop 是你可以在组件上注册的一些自定义 attribute。当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个 property。为了给博文组件传递一个标题，我们可以用一个 props 选项将其包含在该组件可接受的 prop 列表中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;blog-post&#x27;, &#123;</span><br><span class="line">  props: [&#x27;title&#x27;],</span><br><span class="line">  template: &#x27;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个组件默认可以拥有任意数量的 prop，任何值都可以传递给任何 prop。在上述模板中，你会发现我们能够在组件实例中访问这个值，就像访问 <code>data</code> 中的值一样。一个 prop 被注册之后，你就可以像这样把数据作为一个自定义 attribute 传递进来：	</p>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line">&lt;blog-post title=&quot;Blogging with Vue&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line">&lt;blog-post title=&quot;Why Vue is so fun&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然而在一个典型的应用中，你可能在 <code>data</code> 里有一个博文的数组：</p>
<p>​			</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#blog-post-demo&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    posts: [</span><br><span class="line">      &#123; id: 1, title: &#x27;My journey with Vue&#x27; &#125;,</span><br><span class="line">      &#123; id: 2, title: &#x27;Blogging with Vue&#x27; &#125;,</span><br><span class="line">      &#123; id: 3, title: &#x27;Why Vue is so fun&#x27; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>并想要为每篇博文渲染一个组件：</p>
<p>​			</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  v-for=&quot;post in posts&quot;</span><br><span class="line">  v-bind:key=&quot;post.id&quot;</span><br><span class="line">  v-bind:title=&quot;post.title&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上所示，你会发现我们可以使用 <code>v-bind</code> 来动态传递 prop。</p>
<p>这在你一开始不清楚要渲染的具体内容，比如<a target="_blank" rel="noopener" href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-component-blog-post-example">从一个 API 获取博文列表</a>的时候，是非常有用的。</p>
<h3 id="Prop-大小写"><a href="#Prop-大小写" class="headerlink" title="Prop 大小写"></a><p style="font-size:20px">Prop 大小写</p><p></p></h3><p>HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;blog-post&#x27;, &#123;</span><br><span class="line">  // 在 JavaScript 中是 camelCase 的</span><br><span class="line">  props: [&#x27;postTitle&#x27;],</span><br><span class="line">  template: &#x27;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;</span><br><span class="line">&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重申一次，如果你使用字符串模板，那么这个限制就不存在了。</p>
<h3 id="Prop-类型"><a href="#Prop-类型" class="headerlink" title="Prop 类型"></a><p style="font-size:20px">Prop 类型</p></h3><p>到这里，我们只看到了以字符串数组形式列出的 prop：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">props: [&#x27;title&#x27;, &#x27;likes&#x27;, &#x27;isPublished&#x27;, &#x27;commentIds&#x27;, &#x27;author&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型：</p>
<p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: String,</span><br><span class="line">  likes: Number,</span><br><span class="line">  isPublished: Boolean,</span><br><span class="line">  commentIds: Array,</span><br><span class="line">  author: Object,</span><br><span class="line">  callback: Function,</span><br><span class="line">  contactsPromise: Promise // or any other constructor</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这不仅为你的组件提供了文档，还会在它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户。</p>
<p>你会在这个页面接下来的部分看到<strong>类型检查和其它 prop 验证</strong>。</p>
<h3 id="Prop-传值"><a href="#Prop-传值" class="headerlink" title="Prop 传值"></a><p style="font-size:20px">Prop 传值</p></h3><p>像这样，你已经知道了可以像这样给 prop 传入一个静态的值：</p>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你也知道 prop 可以通过 <code>v-bind</code> 动态赋值，例如：</p>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 动态赋予一个变量的值 --&gt;</span><br><span class="line">&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态赋予一个复杂表达式的值 --&gt;</span><br><span class="line">&lt;blog-post</span><br><span class="line">  v-bind:title=&quot;post.title + &#x27; by &#x27; + post.author.name&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述两个示例中，我们传入的值都是字符串类型的，但实际上<strong>任何</strong>类型的值都可以传给一个 prop。</p>
<h4 id="传入一个数字"><a href="#传入一个数字" class="headerlink" title="传入一个数字"></a><p style="font-size:20px">传入一个数字</p></h4><p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span><br><span class="line">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span><br><span class="line">&lt;blog-post v-bind:likes=&quot;42&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 用一个变量进行动态赋值。--&gt;</span><br><span class="line">&lt;blog-post v-bind:likes=&quot;post.likes&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>

<h4 id="传入一个布尔值"><a href="#传入一个布尔值" class="headerlink" title="传入一个布尔值"></a><p style="font-size:20px">传入一个布尔值</p></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;</span><br><span class="line">&lt;blog-post is-published&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span><br><span class="line">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span><br><span class="line">&lt;blog-post v-bind:is-published=&quot;false&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 用一个变量进行动态赋值。--&gt;</span><br><span class="line">&lt;blog-post v-bind:is-published=&quot;post.isPublished&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="传入一个数组"><a href="#传入一个数组" class="headerlink" title="传入一个数组"></a><p style="font-size:20px">传入一个数组</p></h4><p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span><br><span class="line">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span><br><span class="line">&lt;blog-post v-bind:comment-ids=&quot;[234, 266, 273]&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 用一个变量进行动态赋值。--&gt;</span><br><span class="line">&lt;blog-post v-bind:comment-ids=&quot;post.commentIds&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「轻松的小希」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/qq_38490457/article/details/110940631</span><br></pre></td></tr></table></figure>

<h4 id="传入一个对象"><a href="#传入一个对象" class="headerlink" title="传入一个对象"></a><p style="font-size:20px">传入一个对象</p></h4><p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span><br><span class="line">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span><br><span class="line">&lt;blog-post</span><br><span class="line">  v-bind:author=&quot;&#123;</span><br><span class="line">    name: &#x27;Veronica&#x27;,</span><br><span class="line">    company: &#x27;Veridian Dynamics&#x27;</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 用一个变量进行动态赋值。--&gt;</span><br><span class="line">&lt;blog-post v-bind:author=&quot;post.author&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>

<h4 id="传入一个对象的所有属性"><a href="#传入一个对象的所有属性" class="headerlink" title="传入一个对象的所有属性"></a><p style="font-size:20px">传入一个对象的所有属性</p></h4><p>如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 <code>v-bind</code> (取代 <code>v-bind:prop-name</code>)。</p>
<p>例如，对于一个给定的对象 <code>post</code>：</p>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post: &#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  title: &#x27;My Journey with Vue&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的模板：</p>
<p>​			</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post v-bind=&quot;post&quot;&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  v-bind:id=&quot;post.id&quot;</span><br><span class="line">  v-bind:title=&quot;post.title&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Prop-单向数据流"><a href="#Prop-单向数据流" class="headerlink" title="Prop 单向数据流"></a><p style="font-size:20px">Prop 单向数据流</p></h3><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p>
<p>这里有两种常见的试图变更一个 prop 的情形：</p>
<p><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。</strong>在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值：</p>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [&#x27;initialCounter&#x27;],</span><br><span class="line">data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    counter: this.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个 prop 以一种原始的值传入且需要进行转换。</strong>在这种情况下，最好使用这个 prop 的值来定义一个计算属性：</p>
<p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: [&#x27;size&#x27;],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: function () &#123;</span><br><span class="line">    return this.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身<strong>将会</strong>影响到父组件的状态。</p>
<h3 id="Prop-验证"><a href="#Prop-验证" class="headerlink" title="Prop 验证"></a><p style="font-size:20px">Prop 验证</p></h3><p>我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。</p>
<p>为了定制 prop 的验证方式，你可以为 props 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;my-component&#x27;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span><br><span class="line">    propA: Number,</span><br><span class="line">    // 多个可能的类型</span><br><span class="line">    propB: [String, Number],</span><br><span class="line">    // 必填的字符串</span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    // 带有默认值的数字</span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    // 带有默认值的对象</span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      // 对象或数组默认值必须从一个工厂函数获取</span><br><span class="line">      default: function () &#123;</span><br><span class="line">        return &#123; message: &#x27;hello&#x27; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 自定义验证函数</span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: function (value) &#123;</span><br><span class="line">        // 这个值必须匹配下列字符串中的一个</span><br><span class="line">        return [&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;danger&#x27;].indexOf(value) !== -1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。</p>
<p>注意那些 prop 会在一个组件实例创建<strong>之前</strong>进行验证，所以实例的 property (如 <code>data</code>、<code>computed</code> 等) 在 <code>default</code> 或 <code>validator</code> 函数中是不可用的。</p>
<p><code>type</code> 可以是下列原生构造函数中的一个：</p>
<ul>
<li><code>String</code></li>
<li><code>Number</code></li>
<li><code>Boolean</code></li>
<li><code>Array</code></li>
<li><code>Object</code></li>
<li><code>Date</code></li>
<li><code>Function</code></li>
<li><code>Symbol</code></li>
</ul>
<p>额外的，<code>type</code> 还可以是一个自定义的构造函数，并且通过 <code>instanceof</code> 来进行检查确认。例如，给定下列现成的构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person (firstName, lastName) &#123;</span><br><span class="line">  this.firstName = firstName</span><br><span class="line">  this.lastName = lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;blog-post&#x27;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    author: Person</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>来验证 <code>author</code> prop 的值是否是通过 <code>new Person</code> 创建的。</p>
<h3 id="非-Prop-的属性"><a href="#非-Prop-的属性" class="headerlink" title="非 Prop 的属性"></a><p style="font-size:20px">非 Prop 的属性</p></h3><p>一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。</p>
<p>因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。</p>
<p>这也是为什么组件可以接受任意的 attribute，而这些 attribute 会被添加到这个组件的根元素上。</p>
<p>例如，想象一下你通过一个 Bootstrap 插件使用了一个第三方的 <bootstrap-date-input> 组件，这个插件需要在其 <input> 上用到一个 data-date-picker attribute。我们可以将这个 attribute 添加到你的组件实例上：</bootstrap-date-input></p>
<p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bootstrap-date-input data-date-picker=&quot;activated&quot;&gt;&lt;/bootstrap-date-input&gt;</span><br></pre></td></tr></table></figure>

<p>然后这个 <code>data-date-picker=&quot;activated&quot;</code> attribute 就会自动添加到 <code>&lt;bootstrap-date-input&gt;</code> 的根元素上。</p>
<p><strong>替换&#x2F;合并已有的 Attribute</strong></p>
<p>想象一下 <code>&lt;bootstrap-date-input&gt;</code> 的模板是这样的：</p>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;date&quot; class=&quot;form-control&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		为了给我们的日期选择器插件定制一个主题，我们可能需要像这样添加一个特别的类名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bootstrap-date-input</span><br><span class="line">  data-date-picker=&quot;activated&quot;</span><br><span class="line">  class=&quot;date-picker-theme-dark&quot;</span><br><span class="line">&gt;&lt;/bootstrap-date-input&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这种情况下，我们定义了两个不同的 class 的值：</p>
<ul>
<li><code>form-control</code>，这是在组件的模板内设置好的</li>
<li><code>date-picker-theme-dark</code>，这是从组件的父级传入的</li>
</ul>
<p>对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 type&#x3D;”text” 就会替换掉 type&#x3D;”date” 并把它破坏！庆幸的是，class 和 style attribute 会稍微智能一些，即两边的值会被合并起来，从而得到最终的值：form-control date-picker-theme-dark。</p>
<p><strong>禁用 Attribute 继承</strong></p>
<p>如果你<strong>不</strong>希望组件的根元素继承 attribute，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。例如：</p>
<p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;my-component&#x27;, &#123;</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这尤其适合配合实例的 <code>$attrs</code> property 使用，该 property 包含了传递给一个组件的 attribute 名和 attribute 值，例如：</p>
<p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  required: true,</span><br><span class="line">  placeholder: &#x27;Enter your username&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了 <code>inheritAttrs: false</code> 和 <code>$attrs</code>，你就可以手动决定这些 attribute 会被赋予哪个元素。在撰写<strong>基础组件</strong>的时候是常会用到的：</p>
<p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;base-input&#x27;, &#123;</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  props: [&#x27;label&#x27;, &#x27;value&#x27;],</span><br><span class="line">  template: `</span><br><span class="line">    &lt;label&gt;</span><br><span class="line">      &#123;&#123; label &#125;&#125;</span><br><span class="line">      &lt;input</span><br><span class="line">        v-bind=&quot;$attrs&quot;</span><br><span class="line">        v-bind:value=&quot;value&quot;</span><br><span class="line">        v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class="line">      &gt;</span><br><span class="line">    &lt;/label&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意：<code>inheritAttrs: false</code> 选项<strong>不会</strong>影响 <code>style</code> 和 <code>class</code> 的绑定。</p>
<p>这个模式允许你在使用基础组件的时候更像是使用原始的 HTML 元素，而不会担心哪个元素是真正的根元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-input</span><br><span class="line">  v-model=&quot;username&quot;</span><br><span class="line">  required</span><br><span class="line">  placeholder=&quot;Enter your username&quot;</span><br><span class="line">&gt;&lt;/base-input&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="监听子组件的事件"><a href="#监听子组件的事件" class="headerlink" title="监听子组件的事件"></a>监听子组件的事件</h2><h3 id="子组件触发父组件事件"><a href="#子组件触发父组件事件" class="headerlink" title="子组件触发父组件事件"></a><p style="font-size:20px">子组件触发父组件事件</p></h3><p>在我们开发 <blog-post> 组件时，它的一些功能可能要求我们和父级组件进行沟通。</blog-post></p>
<p>例如我们可能会引入一个辅助功能来放大博文的字号，同时让页面的其它部分保持默认的字号。</p>
<p>在其父组件中，我们可以通过添加一个 postFontSize 数据 property 来支持这个功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#blog-posts-events-demo&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    posts: [/* ... */],</span><br><span class="line">    postFontSize: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>它可以在模板中用来控制所有博文的字号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;blog-post&#x27;, &#123;</span><br><span class="line">  props: [&#x27;post&#x27;],</span><br><span class="line">  template: `</span><br><span class="line">    &lt;div class=&quot;blog-post&quot;&gt;</span><br><span class="line">      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;</span><br><span class="line">      &lt;button&gt;</span><br><span class="line">        Enlarge text</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题是这个按钮不会做任何事：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;</span><br><span class="line">  Enlarge text</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当点击这个按钮时，我们需要告诉父级组件放大所有博文的文本。</p>
<p>幸好 Vue 实例提供了一个自定义事件的系统来解决这个问题。</p>
<p>父级组件可以像处理 native DOM 事件一样通过 <code>v-on</code> 监听子组件实例的任意事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  ...</span><br><span class="line">  v-on:enlarge-text=&quot;postFontSize += 0.1&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时子组件可以通过调用内建的 <strong>$emit</strong> 方法 并传入事件名称来触发一个事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click=&quot;$emit(&#x27;enlarge-text&#x27;)&quot;&gt;</span><br><span class="line">  Enlarge text</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有了这个 <code>v-on:enlarge-text=&quot;postFontSize += 0.1&quot;</code> 监听器，父级组件就会接收该事件并更新 <code>postFontSize</code> 的值。</p>
<h3 id="使用事件抛出特定的值"><a href="#使用事件抛出特定的值" class="headerlink" title="使用事件抛出特定的值"></a><p style="font-size:20px">使用事件抛出特定的值</p></h3><p>有的时候用一个事件来抛出一个特定的值是非常有用的。</p>
<p>例如我们可能想让 <code>&lt;blog-post&gt;</code> 组件决定它的文本要放大多少。</p>
<p>这时可以使用 <code>$emit</code> 的第二个参数来提供这个值：</p>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click=&quot;$emit(&#x27;enlarge-text&#x27;, 0.1)&quot;&gt;</span><br><span class="line">  Enlarge text</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后当在父级组件监听这个事件的时候，我们可以通过 <code>$event</code> 访问到被抛出的这个值：</p>
<p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  ...</span><br><span class="line">  v-on:enlarge-text=&quot;postFontSize += $event&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者，如果这个事件处理函数是一个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  ...</span><br><span class="line">  v-on:enlarge-text=&quot;onEnlargeText&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么这个值将会作为第一个参数传入这个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  onEnlargeText: function (enlargeAmount) &#123;</span><br><span class="line">    this.postFontSize += enlargeAmount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义事件的事件名称"><a href="#自定义事件的事件名称" class="headerlink" title="自定义事件的事件名称"></a><p style="font-size:20px">自定义事件的事件名称</p></h3><p>不同于组件和 prop，事件名不存在任何自动化的大小写转换。</p>
<p>而是触发的事件名需要完全匹配监听这个事件所用的名称。</p>
<p>举个例子，如果触发一个 camelCase 名字的事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&#x27;myEvent&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>则监听这个名字的 kebab-case 版本是不会有任何效果的：</p>
<p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 没有效果 --&gt;</span><br><span class="line">&lt;my-component v-on:my-event=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>

<p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。</p>
<p>并且 v-on 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 v-on:myEvent 将会变成 v-on:myevent，导致 myEvent 不可能被监听到。</p>
<p>因此，我们推荐你始终使用 kebab-case 的事件名。</p>
<h3 id="在组件上使用v-model"><a href="#在组件上使用v-model" class="headerlink" title="在组件上使用v-model"></a><p style="font-size:20px">在组件上使用v-model</p></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;searchText&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  v-bind:value=&quot;searchText&quot;</span><br><span class="line">  v-on:input=&quot;searchText = $event.target.value&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>当用在组件上时，<code>v-model</code> 则会这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-input</span><br><span class="line">  v-bind:value=&quot;searchText&quot;</span><br><span class="line">  v-on:input=&quot;searchText = $event&quot;</span><br><span class="line">&gt;&lt;/custom-input&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了让它正常工作，这个组件内的 <code>&lt;input&gt;</code> 必须：</p>
<ul>
<li>将其 <code>value</code> attribute 绑定到一个名叫 <code>value</code> 的 prop 上</li>
<li>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>input</code> 事件抛出</li>
</ul>
<p>写成代码之后是这样的：</p>
<p>​			</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;custom-input&#x27;, &#123;</span><br><span class="line">  props: [&#x27;value&#x27;],</span><br><span class="line">  template: `</span><br><span class="line">    &lt;input</span><br><span class="line">      v-bind:value=&quot;value&quot;</span><br><span class="line">      v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>现在 <code>v-model</code> 就应该可以在这个组件上完美地工作起来了：</p>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value">不同的目的</a>。2.2.0+ 新增 <code>model</code> 选项可以用来避免这样的冲突：</p>
<p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;base-checkbox&#x27;, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &#x27;checked&#x27;,</span><br><span class="line">    event: &#x27;change&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: Boolean</span><br><span class="line">  &#125;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;input</span><br><span class="line">      type=&quot;checkbox&quot;</span><br><span class="line">      v-bind:checked=&quot;checked&quot;</span><br><span class="line">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>现在在这个组件上使用 <code>v-model</code> 的时候：</p>
<p>​			</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-checkbox</span><br><span class="line">  v-bind:checked=&quot;lovingVue&quot;</span><br><span class="line">  v-on:change=&quot;lovingVue = $event&quot;</span><br><span class="line">&gt;&lt;/base-checkbox&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的 lovingVue 的值将会传入这个名为 checked 的 prop。同时原来需要触发 input 事件改为了 change 事件。</p>
<p>因此，当 <base-checkbox> 触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的 property 将会被更新。</base-checkbox></p>
<p>注意你仍然需要在组件的 props 选项里声明 checked 这个 prop。</p>
<h3 id="将原生事件绑定到组件"><a href="#将原生事件绑定到组件" class="headerlink" title="将原生事件绑定到组件"></a><p style="font-size:20px">将原生事件绑定到组件</p></h3><p>你可能有很多次想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 <code>v-on</code> 的 <code>.native</code> 修饰符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-input v-on:focus.native=&quot;onFocus&quot;&gt;&lt;/base-input&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在有的时候这是很有用的，不过在你尝试监听一个类似 <code>&lt;input&gt;</code> 的非常特定的元素时，这并不是个好主意。</p>
<p>比如上述 <code>&lt;base-input&gt;</code> 组件可能做了如下重构，所以根元素实际上是一个 <code>&lt;label&gt;</code> 元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;label&gt;</span><br><span class="line">  &#123;&#123; label &#125;&#125;</span><br><span class="line">  &lt;input</span><br><span class="line">    v-bind=&quot;$attrs&quot;</span><br><span class="line">    v-bind:value=&quot;value&quot;</span><br><span class="line">    v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class="line">  &gt;</span><br><span class="line">&lt;/label&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时，父级的 <code>.native</code> 监听器将静默失败。它不会产生任何报错，而且 <code>onFocus</code> 处理函数不会如你预期地被调用。</p>
<p>为了解决这个问题，Vue 提供了一个 <code>$listeners</code> property，它是一个对象，里面包含了作用在这个组件上的所有监听器。例如：</p>
<p>​			</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  focus: function (event) &#123; /* ... */ &#125;</span><br><span class="line">  input: function (value) &#123; /* ... */ &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有了这个 $listeners property，你就可以配合 v-on&#x3D;”$listeners” 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 <input> 的你希望它也可以配合 v-model 工作的组件来说，为这些监听器创建一个类似下述 inputListeners 的计算属性通常是非常有用的：</p>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;base-input&#x27;, &#123;</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  props: [&#x27;label&#x27;, &#x27;value&#x27;],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    inputListeners: function () &#123;</span><br><span class="line">      var vm = this</span><br><span class="line">      // `Object.assign` 将所有的对象合并为一个新对象</span><br><span class="line">      return Object.assign(&#123;&#125;,</span><br><span class="line">        // 我们从父级添加所有的监听器</span><br><span class="line">        this.$listeners,</span><br><span class="line">        // 然后我们添加自定义监听器，</span><br><span class="line">        // 或覆写一些监听器的行为</span><br><span class="line">        &#123;</span><br><span class="line">          // 这里确保组件配合 `v-model` 的工作</span><br><span class="line">          input: function (event) &#123;</span><br><span class="line">            vm.$emit(&#x27;input&#x27;, event.target.value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;label&gt;</span><br><span class="line">      &#123;&#123; label &#125;&#125;</span><br><span class="line">      &lt;input</span><br><span class="line">        v-bind=&quot;$attrs&quot;</span><br><span class="line">        v-bind:value=&quot;value&quot;</span><br><span class="line">        v-on=&quot;inputListeners&quot;</span><br><span class="line">      &gt;</span><br><span class="line">    &lt;/label&gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在 <code>&lt;base-input&gt;</code> 组件是一个<strong>完全透明的包裹器</strong>了，也就是说它可以完全像一个普通的 <code>&lt;input&gt;</code> 元素一样使用了：所有跟它相同的 attribute 和监听器都可以工作，不必再使用 <code>.native</code> 监听器。</p>
<h3 id="sync-修饰"><a href="#sync-修饰" class="headerlink" title=".sync 修饰"></a><p style="font-size:20px"><code>.sync</code> 修饰</p></h3><p>2.3.0+ 新增</p>
<p>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件都没有明显的变更来源。</p>
<p>这也是为什么我们推荐以 update:myPropName 的模式触发事件取而代之。举个例子，在一个包含 title prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&#x27;update:title&#x27;, newTitle)</span><br></pre></td></tr></table></figure>

<p>然后父组件可以监听那个事件并根据需要更新一个本地的数据 property。例如：</p>
<p>​			</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;text-document</span><br><span class="line">  v-bind:title=&quot;doc.title&quot;</span><br><span class="line">  v-on:update:title=&quot;doc.title = $event&quot;</span><br><span class="line">&gt;&lt;/text-document&gt;</span><br></pre></td></tr></table></figure>

<p>为了方便起见，我们为这种模式提供一个缩写，即 <code>.sync</code> 修饰符：</p>
<p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;text-document v-bind:title.sync=&quot;doc.title&quot;&gt;&lt;/text-document&gt;</span><br></pre></td></tr></table></figure>

<p>注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync&#x3D;”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的 property 名，类似 v-model。</p>
<p>当我们用一个对象同时设置多个 prop 的时候，也可以将这个 .sync 修饰符和 v-bind 配合使用：</p>
<p>​		</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;text-document v-bind.sync=&quot;doc&quot;&gt;&lt;/text-document&gt;</span><br></pre></td></tr></table></figure>

<p>这样会把 doc 对象中的每一个 property (如 title) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器。</p>
<p>将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync&#x3D;”{ title: doc.title }”，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Mr.张</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://zylove.com/2023/09/06/Vue2/">http://zylove.com/2023/09/06/Vue2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="https://ts1.cn.mm.bing.net/th/id/R-C.2eb9919b0ef20e2f671870ee9cb1889c?rik=oRJmtjJly1kcHg&amp;riu=http%3a%2f%2fi0.hdslb.com%2fbfs%2farchive%2faa512eb0807633fce6d34810e7ef343fb416f707.jpg&amp;ehk=94crFqBa0S8vifTPvminExzxIZWDbTJ7zsm8IyJDyrY%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Vue%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是 Vue？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue2-x-%E7%89%B9%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">Vue2.x 特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue2-x-%E5%85%A5%E9%97%A8"><span class="toc-number">3.</span> <span class="toc-text">Vue2.x 入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2-x-%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.1.</span> <span class="toc-text">Vue2.x 实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#el"><span class="toc-number">3.2.</span> <span class="toc-text">el</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#data"><span class="toc-number">3.3.</span> <span class="toc-text">data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#methods"><span class="toc-number">3.4.</span> <span class="toc-text">methods</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#watch"><span class="toc-number">3.5.</span> <span class="toc-text">watch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#computed"><span class="toc-number">3.6.</span> <span class="toc-text">computed</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue2-x-%E6%8C%87%E4%BB%A4%E6%8C%87%E5%8D%97"><span class="toc-number">4.</span> <span class="toc-text">Vue2.x 指令指南</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">模板语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%80%BC"><span class="toc-number">4.1.1.</span> <span class="toc-text">插值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#text"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">text</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#html"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">html</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#attribute"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">attribute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#expression"><span class="toc-number">4.1.1.4.</span> <span class="toc-text">expression</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="toc-number">4.1.2.</span> <span class="toc-text">指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">动态参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">修饰符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%A9%E5%86%99"><span class="toc-number">4.1.3.</span> <span class="toc-text">缩写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#v-bind-%E7%BC%A9%E5%86%99"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">v-bind 缩写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-on-%E7%BC%A9%E5%86%99"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">v-on 缩写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5"><span class="toc-number">4.1.4.</span> <span class="toc-text">深入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#v-bind-%E6%B7%B1%E5%85%A5"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">v-bind 深入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-on-%E6%B7%B1%E5%85%A5"><span class="toc-number">4.1.4.2.</span> <span class="toc-text">v-on 深入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="toc-number">4.2.</span> <span class="toc-text">样式绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A-class"><span class="toc-number">4.2.1.</span> <span class="toc-text">绑定 class</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">对象语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%AF%AD%E6%B3%95"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">数组语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">用在组件上</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-number">4.3.</span> <span class="toc-text">条件渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#v-if"><span class="toc-number">4.3.1.</span> <span class="toc-text">v-if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-show"><span class="toc-number">4.3.2.</span> <span class="toc-text">v-show</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93"><span class="toc-number">4.4.</span> <span class="toc-text">列表渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-number">4.4.1.</span> <span class="toc-text">v-for 遍历数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for-%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.4.2.</span> <span class="toc-text">v-for 遍历对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for-%E7%BB%B4%E6%8A%A4%E7%8A%B6%E6%80%81"><span class="toc-number">4.4.3.</span> <span class="toc-text">v-for 维护状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for-%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B"><span class="toc-number">4.4.4.</span> <span class="toc-text">v-for 更新检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for-%E8%BF%87%E6%BB%A4%E6%8E%92%E5%BA%8F"><span class="toc-number">4.4.5.</span> <span class="toc-text">v-for 过滤排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for-%E9%99%90%E5%88%B6%E8%8C%83%E5%9B%B4"><span class="toc-number">4.4.6.</span> <span class="toc-text">v-for 限制范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for-%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%B8%8A%E4%BD%BF%E7%94%A8"><span class="toc-number">4.4.7.</span> <span class="toc-text">v-for 在模板上使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for-%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8"><span class="toc-number">4.4.8.</span> <span class="toc-text">v-for 在组件上使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.4.9.</span> <span class="toc-text">v-for 注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">4.5.</span> <span class="toc-text">事件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-number">4.5.1.</span> <span class="toc-text">事件监听</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86-1"><span class="toc-number">4.5.2.</span> <span class="toc-text">事件处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.5.3.</span> <span class="toc-text">事件修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.5.4.</span> <span class="toc-text">按键修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.5.5.</span> <span class="toc-text">系统修饰符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E7%BB%91%E5%AE%9A"><span class="toc-number">4.6.</span> <span class="toc-text">表单绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95"><span class="toc-number">4.6.1.</span> <span class="toc-text">基础用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC"><span class="toc-number">4.6.1.1.</span> <span class="toc-text">文本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC"><span class="toc-number">4.6.1.2.</span> <span class="toc-text">多行文本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E9%80%89%E6%A1%86"><span class="toc-number">4.6.1.3.</span> <span class="toc-text">复选框</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%80%89%E6%8C%89%E9%92%AE"><span class="toc-number">4.6.1.4.</span> <span class="toc-text">单选按钮</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%A1%86"><span class="toc-number">4.6.1.5.</span> <span class="toc-text">选择框</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%BB%91%E5%AE%9A"><span class="toc-number">4.6.2.</span> <span class="toc-text">值绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E9%80%89%E6%A1%86-1"><span class="toc-number">4.6.2.1.</span> <span class="toc-text">复选框</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%80%89%E6%8C%89%E9%92%AE-1"><span class="toc-number">4.6.2.2.</span> <span class="toc-text">单选按钮</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%A1%86-1"><span class="toc-number">4.6.2.3.</span> <span class="toc-text">选择框</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6-1"><span class="toc-number">4.6.3.</span> <span class="toc-text">修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lazy"><span class="toc-number">4.6.3.1.</span> <span class="toc-text">.lazy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#number"><span class="toc-number">4.6.3.2.</span> <span class="toc-text">.number</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#trim"><span class="toc-number">4.6.3.3.</span> <span class="toc-text">.trim</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E6%8C%87%E4%BB%A4"><span class="toc-number">4.7.</span> <span class="toc-text">其它指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#v-pre"><span class="toc-number">4.7.0.1.</span> <span class="toc-text">v-pre</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue2-x-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.</span> <span class="toc-text">Vue2.x 生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="toc-number">5.1.</span> <span class="toc-text">生命周期钩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%92%A9%E5%AD%90%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.2.</span> <span class="toc-text">钩子详细介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#beforeCreate"><span class="toc-number">5.2.1.</span> <span class="toc-text">beforeCreate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#created"><span class="toc-number">5.2.2.</span> <span class="toc-text">created</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#beforeMount"><span class="toc-number">5.2.3.</span> <span class="toc-text">beforeMount</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mounted"><span class="toc-number">5.2.4.</span> <span class="toc-text">mounted</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#beforeUpdate"><span class="toc-number">5.2.5.</span> <span class="toc-text">beforeUpdate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#updated"><span class="toc-number">5.2.6.</span> <span class="toc-text">updated</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#activated"><span class="toc-number">5.2.7.</span> <span class="toc-text">activated</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deactivated"><span class="toc-number">5.2.8.</span> <span class="toc-text">deactivated</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#beforeDestroy"><span class="toc-number">5.2.9.</span> <span class="toc-text">beforeDestroy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#destroyed"><span class="toc-number">5.2.10.</span> <span class="toc-text">destroyed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#errorCaptured"><span class="toc-number">5.2.11.</span> <span class="toc-text">errorCaptured</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA"><span class="toc-number">5.3.</span> <span class="toc-text">生命周期图示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue2-x-%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB"><span class="toc-number">6.</span> <span class="toc-text">Vue2.x 过渡动画</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%BB%84%E4%BB%B6%E8%BF%87%E6%B8%A1%E5%92%8C%E5%8A%A8%E7%94%BB"><span class="toc-number">6.2.</span> <span class="toc-text">元素组件过渡和动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%B8%A1%E6%BC%94%E7%A4%BA"><span class="toc-number">6.2.1.</span> <span class="toc-text">过渡演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.2.</span> <span class="toc-text">钩子函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%B8%A1%E7%B1%BB%E5%90%8D"><span class="toc-number">6.2.3.</span> <span class="toc-text">过渡类名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E8%BF%87%E6%B8%A1"><span class="toc-number">6.2.4.</span> <span class="toc-text">CSS 过渡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E5%8A%A8%E7%94%BB"><span class="toc-number">6.2.5.</span> <span class="toc-text">CSS 动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%B8%A1%E7%9A%84%E7%B1%BB%E5%90%8D"><span class="toc-number">6.2.6.</span> <span class="toc-text">自定义过渡的类名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E8%BF%87%E6%B8%A1%E5%92%8C%E5%8A%A8%E7%94%BB"><span class="toc-number">6.2.7.</span> <span class="toc-text">同时使用过渡和动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E6%80%A7%E7%9A%84%E8%BF%87%E6%B8%A1%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4"><span class="toc-number">6.2.8.</span> <span class="toc-text">显性的过渡持续时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0%E8%BF%87%E6%B8%A1%E5%92%8C%E5%8A%A8%E7%94%BB"><span class="toc-number">6.3.</span> <span class="toc-text">多个元素过渡和动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%E8%BF%87%E6%B8%A1%E5%92%8C%E5%8A%A8%E7%94%BB"><span class="toc-number">6.4.</span> <span class="toc-text">多个组件过渡和动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E6%B8%B2%E6%9F%93%E8%BF%87%E6%B8%A1"><span class="toc-number">6.5.</span> <span class="toc-text">初始渲染过渡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E8%BF%87%E6%B8%A1"><span class="toc-number">6.6.</span> <span class="toc-text">列表过渡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E7%9A%84%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C"><span class="toc-number">6.6.1.</span> <span class="toc-text">列表的过渡效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E8%BF%87%E6%B8%A1"><span class="toc-number">6.6.2.</span> <span class="toc-text">列表的排序过渡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E7%9A%84%E4%BA%A4%E9%94%99%E8%BF%87%E6%B8%A1"><span class="toc-number">6.6.3.</span> <span class="toc-text">列表的交错过渡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%A4%8D%E7%94%A8%E8%BF%87%E6%B8%A1"><span class="toc-number">6.7.</span> <span class="toc-text">可复用过渡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%BF%87%E6%B8%A1"><span class="toc-number">6.8.</span> <span class="toc-text">动态过渡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BF%87%E6%B8%A1"><span class="toc-number">6.9.</span> <span class="toc-text">状态过渡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%8A%B6%E6%80%81%E4%B8%8E%E4%BE%A6%E5%90%AC%E5%99%A8"><span class="toc-number">6.9.1.</span> <span class="toc-text">动态状态与侦听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%8A%B6%E6%80%81%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C"><span class="toc-number">6.9.2.</span> <span class="toc-text">动态状态过渡效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E8%BF%87%E6%B8%A1%E6%94%BE%E5%88%B0%E7%BB%84%E4%BB%B6%E9%87%8C"><span class="toc-number">6.9.3.</span> <span class="toc-text">把过渡放到组件里</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue2-x-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">Vue2.x 过滤器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue2-x-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82"><span class="toc-number">8.</span> <span class="toc-text">Vue2.x 网络请求</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-resource"><span class="toc-number">8.1.</span> <span class="toc-text">vue-resource</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">8.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3"><span class="toc-number">8.1.2.</span> <span class="toc-text">文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">8.1.3.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.1.4.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axios"><span class="toc-number">8.2.</span> <span class="toc-text">axios</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">8.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">8.2.2.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue2-x-%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0"><span class="toc-number">9.</span> <span class="toc-text">Vue2.x 组件学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.1.</span> <span class="toc-text">组件的示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%8D%E7%94%A8"><span class="toc-number">9.2.</span> <span class="toc-text">组件的复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">9.3.</span> <span class="toc-text">组件的组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="toc-number">9.4.</span> <span class="toc-text">组件的注册</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%90%8D%E7%A7%B0"><span class="toc-number">9.4.1.</span> <span class="toc-text">组件名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C"><span class="toc-number">9.4.2.</span> <span class="toc-text">全局注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C"><span class="toc-number">9.4.3.</span> <span class="toc-text">局部注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.4.4.</span> <span class="toc-text">模块系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">9.5.</span> <span class="toc-text">向子组件传递数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Prop-%E5%85%A5%E9%97%A8"><span class="toc-number">9.5.1.</span> <span class="toc-text">Prop 入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prop-%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="toc-number">9.5.2.</span> <span class="toc-text">Prop 大小写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prop-%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.5.3.</span> <span class="toc-text">Prop 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prop-%E4%BC%A0%E5%80%BC"><span class="toc-number">9.5.4.</span> <span class="toc-text">Prop 传值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">9.5.4.1.</span> <span class="toc-text">传入一个数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E5%B8%83%E5%B0%94%E5%80%BC"><span class="toc-number">9.5.4.2.</span> <span class="toc-text">传入一个布尔值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="toc-number">9.5.4.3.</span> <span class="toc-text">传入一个数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.5.4.4.</span> <span class="toc-text">传入一个对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="toc-number">9.5.4.5.</span> <span class="toc-text">传入一个对象的所有属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prop-%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">9.5.5.</span> <span class="toc-text">Prop 单向数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prop-%E9%AA%8C%E8%AF%81"><span class="toc-number">9.5.6.</span> <span class="toc-text">Prop 验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E-Prop-%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">9.5.7.</span> <span class="toc-text">非 Prop 的属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.6.</span> <span class="toc-text">监听子组件的事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BB%84%E4%BB%B6%E8%A7%A6%E5%8F%91%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.6.1.</span> <span class="toc-text">子组件触发父组件事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E6%8A%9B%E5%87%BA%E7%89%B9%E5%AE%9A%E7%9A%84%E5%80%BC"><span class="toc-number">9.6.2.</span> <span class="toc-text">使用事件抛出特定的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%90%8D%E7%A7%B0"><span class="toc-number">9.6.3.</span> <span class="toc-text">自定义事件的事件名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8v-model"><span class="toc-number">9.6.4.</span> <span class="toc-text">在组件上使用v-model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%88%B0%E7%BB%84%E4%BB%B6"><span class="toc-number">9.6.5.</span> <span class="toc-text">将原生事件绑定到组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sync-%E4%BF%AE%E9%A5%B0"><span class="toc-number">9.6.6.</span> <span class="toc-text">.sync 修饰</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mr.张</div><div class="author-info__description"></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chenxz21/bcxm" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">微信公众号: 小白一只手</div></div></div></div></main><footer id="footer" style="background: #FFFFFF"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Mr.张</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/chenxz21/hexo-theme-bcxm">Bcxm</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/leancloud-storage@4.10.0/dist/av-min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>